<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tearing · ModelingToolkit Course</title><meta name="title" content="Tearing · ModelingToolkit Course"/><meta property="og:title" content="Tearing · ModelingToolkit Course"/><meta property="twitter:title" content="Tearing · ModelingToolkit Course"/><meta name="description" content="Documentation for ModelingToolkit Course."/><meta property="og:description" content="Documentation for ModelingToolkit Course."/><meta property="twitter:description" content="Documentation for ModelingToolkit Course."/><meta property="og:url" content="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture8/"/><meta property="twitter:url" content="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture8/"/><link rel="canonical" href="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture8/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkit Course</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../syllabus/">Syllabus</a></li><li><a class="tocitem" href="../lecture1/">Introduction to acausal modeling for physical systems with ModelingToolkit.jl</a></li><li><a class="tocitem" href="../lecture2/">Developing high-fidelity models of hydraulic systems</a></li><li><a class="tocitem" href="../lecture3/">Solvers for Non-Stiff Ordinary Differential Equations</a></li><li><a class="tocitem" href="../lecture4/">Numerical Methods for Stiff ODEs and Differential-Algebraic Equations</a></li><li><a class="tocitem" href="../lecture6/">Debugging difficult stiff ODE/DAE models</a></li><li><a class="tocitem" href="../lecture7/">Lecture 7: Numerical and Structural Characterizations for DAEs</a></li><li class="is-active"><a class="tocitem" href>Tearing</a><ul class="internal"><li><a class="tocitem" href="#Demo"><span>Demo</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tearing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tearing</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitCourse" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitCourse/blob/main/docs/src/lectures/lecture8.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tearing"><a class="docs-heading-anchor" href="#Tearing">Tearing</a><a id="Tearing-1"></a><a class="docs-heading-anchor-permalink" href="#Tearing" title="Permalink"></a></h1><div class="admonition is-category-definition"><header class="admonition-header">Induced Directed Graphs</header><div class="admonition-body"><p>The induced directed graph <span>$G = (V, E_v)$</span> from the destination vertices of a bipartite graph <span>$(U, V, E)$</span> and a perfect matching <span>$M$</span> is defined as</p><p class="math-container">\[E_v = \{(i, j): (M(i), j) \in E\}.\]</p><p>Similarly, the induced directed graph <span>$G = (V, E_u)$</span> from the source vertices is defined as</p><p class="math-container">\[E_u = \{(i, j): (i, M^{-1}(j)) \in E\}.\]</p></div></div><div class="admonition is-category-definition"><header class="admonition-header">Strongly Connected Component</header><div class="admonition-body"><p>A strongly connected component <span>$c\subseteq E$</span> of a directed graph <span>$G = (V, E)$</span> is a maximum cardinality set of vertices such that any pair <span>$i \in c, j \in c$</span>, there exists a path <span>$i \rightsquigarrow j$</span> in <span>$G$</span>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Strongly Connected Components Uniqueness Theorem</header><div class="admonition-body"><p>The strongly connected components are unique for induced directed graphs from bipartite graphs with a perfect matching.</p><h4>Proof:</h4><p>See <sup class="footnote-reference"><a id="citeref-DulmageMendelsohn1958" href="#footnote-DulmageMendelsohn1958">[DulmageMendelsohn1958]</a></sup>.</p></div></div><h4 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h4><p>Consider a nonlinear system represented by</p><p class="math-container">\[f_1(v_1, v_3) = 0
f_2(v_1, v_3) = 0
f_3(v_1, v_2) = 0\]</p><p>The incidence matrix is</p><p class="math-container">\[\begin{pmatrix}
1 &amp; 0 &amp; 1 \\
1 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 0
\end{pmatrix}\]</p><p>where a perfect matching <span>$m$</span> is then defined as</p><p class="math-container">\[1 \mapsto 1, 2 \mapsto 3, 3 \mapsto 2.\]</p><p>The permuted matrix is then</p><p class="math-container">\[\begin{pmatrix}
1 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 1
\end{pmatrix}.\]</p><p>The matching can be interpreted as a solvability assignment, i.e.</p><p class="math-container">\[v_1 = \hat{f}_1(v_3)
v_2 = \hat{f}_3(v_1)
v_3 = \hat{f}_2(v_2)\]</p><p>Even if all <span>$\{\hat{f}_i\}$</span> are symbolically solvable, the above assignment will not work because the interdependence of variables. The strongly connected component definition captures this idea well. Variables in a non-trivial strongly connected component are the largest set of variables that are interdependent. The strongly connected components of the above system are <span>$\{\{1, 3\}, \{2\}\}$</span>. Thus, by the previous matching, we should reorder the equations as <span>$e_1, e_2, e_3$</span> and variables as <span>$v_1, v_3, v_2$</span> to isolate the interdependent part. The resulting system is then</p><p class="math-container">\[\begin{pmatrix}
1 &amp; 1 &amp; 0 \\
1 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 1
\end{pmatrix}.\]</p><p>Note that resulting matrix is block lower triangular and this is not a coincidence. We can always reorder the system to be block lower triangular granted by the following theorem.</p><div class="admonition is-category-definition"><header class="admonition-header">Condensation Graph</header><div class="admonition-body"><p>A condensation graph <span>$G_c = (V_c, E_c)$</span> of a directed graph <span>$G = (V, E)$</span> is a directed graph that has vertices</p><p class="math-container">\[V_c = \{\text{strongly connected components of } G\},\]</p><p>and edges</p><p class="math-container">\[E_c = \{(i, j): \exists i_e \in i, j_e \in j, i_e \ne j_e \land (i_e, j_e)
\in E\}.\]</p></div></div><div class="admonition is-info"><header class="admonition-header">Condensation Graphs are Acyclic Theorem</header><div class="admonition-body"><p>The condensation graph <span>$G_c = (V_c, E_c)$</span> induced from the directed graph <span>$G = (V, E)$</span> is acyclic.</p><h4>Proof:</h4><p>Suppose <span>$G_c$</span> is cyclic with a cycle consisting of vertices <span>$s = \{v_1, v_2, ...\} \subseteq V_c$</span>. Then, any original vertices in <span>$v_i$</span> has a path to any vertices in <span>$v_j$</span> for all <span>$i, j$</span>. Thus, <span>$G_c$</span> must have only one vertex. By the definition of a condensation graph, <span>$G_c$</span> must has no edges, and therefore, no cycles.</p></div></div><p>Since the condensation graph has no cycles, we can topologically sort strongly connected components so that the resulting system is always block lower triangular. Further, each block on the diagonal must be square, because the perfect matching will map all variables in each strongly connected components to distinct equations.</p><h2 id="Demo"><a class="docs-heading-anchor" href="#Demo">Demo</a><a id="Demo-1"></a><a class="docs-heading-anchor-permalink" href="#Demo" title="Permalink"></a></h2><pre><code class="language-julia hljs">using ModelingToolkit, OrdinaryDiffEq, LinearAlgebra
import ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible as IC
import ModelingToolkitStandardLibrary.Blocks as B
import ModelingToolkitStandardLibrary.Mechanical.Translational as T

@parameters t
D = Differential(t)

function System(use_input, f; name)
    @parameters t

    pars = @parameters begin
        p_s = 200e5
        p_r = 5e5

        A_1 = 360e-4
        A_2 = 360e-4

        p_1 = 45e5
        p_2 = 45e5

        l_1 = 0.01
        l_2 = 0.05
        m_f = 250
        g = 0

        d = 100e-3

        Cd = 0.01

        m_piston = 880
    end

    vars = @variables begin
        ddx(t) = 0
    end

    systems = @named begin
        src = IC.FixedPressure(; p = p_s)
        valve = IC.SpoolValve2Way(; p_s_int = p_s, p_a_int = p_1, p_b_int = p_2,
            p_r_int = p_r, g, m = m_f, x_int = 0, d, Cd)
        piston = IC.Actuator(5;
            p_a_int = p_1,
            p_b_int = p_2,
            area_a = A_1,
            area_b = A_2,
            length_a_int = l_1,
            length_b_int = l_2,
            m = m_piston,
            g = 0,
            x_int = 0,
            minimum_volume_a = A_1 * 1e-3,
            minimum_volume_b = A_2 * 1e-3,
            damping_volume_a = A_1 * 5e-3,
            damping_volume_b = A_2 * 5e-3)
        body = T.Mass(; m = 1500)
        pipe = IC.Tube(5; p_int = p_2, area = A_2, length = 2.0)
        snk = IC.FixedPressure(; p = p_r)
        pos = T.Position()

        m1 = IC.FlowDivider(; p_int = p_2, n = 3)
        m2 = IC.FlowDivider(; p_int = p_2, n = 3)

        fluid = IC.HydraulicFluid()
    end

    if use_input
        @named input = B.SampledData(Float64)
    else
        @named input = B.TimeVaryingFunction(f)
    end

    push!(systems, input)

    eqs = [connect(input.output, pos.s)
        connect(valve.flange, pos.flange)
        connect(valve.port_a, piston.port_a)
        connect(piston.flange, body.flange)
        connect(piston.port_b, m1.port_a)
        connect(m1.port_b, pipe.port_b)
        connect(pipe.port_a, m2.port_b)
        connect(m2.port_a, valve.port_b)
        connect(src.port, valve.port_s)
        connect(snk.port, valve.port_r)
        connect(fluid, src.port, snk.port)
        D(body.v) ~ ddx]

    ODESystem(eqs, t, vars, pars; name, systems)
end

@named system = System(true, nothing)

# sys = structural_simplify(system)
using ModelingToolkit.StructuralTransformations, ModelingToolkit.BipartiteGraphs,
    Graphs
ts = TearingState(ModelingToolkit.expand_connections(system))
m = BipartiteGraphs.maximal_matching(ts.structure.graph, _-&gt;true, x-&gt;ts.structure.var_to_diff[x] === nothing);
count(x-&gt;x isa Int, m)
count(x-&gt;x===nothing, ts.structure.eq_to_diff)
ModelingToolkit.pantelides!(ts)
m = BipartiteGraphs.maximal_matching(ts.structure.graph, x-&gt;ts.structure.eq_to_diff[x]===nothing, x-&gt;ts.structure.var_to_diff[x] === nothing);
count(x-&gt;x isa Int, m)
count(x-&gt;x===nothing, ts.structure.eq_to_diff)
M = incidence_matrix(ts.structure.graph)
A = M[Int[m[i] for i in eachindex(m) if m[i] isa Int], Int[i for i in eachindex(m) if m[i] isa Int]]
all(isequal(1), diag(A))
g = BipartiteGraphs.DiCMOBiGraph{true}(complete(ts.structure.graph), complete(m));
scc = strongly_connected_components(g);
M[Int[m[i] for i in reduce(vcat, scc) if m[i] isa Int], Int[i for i in reduce(vcat, scc) if m[i] isa Int]]
for c in scc
    length(c) &gt; 1 || continue
    B = M[Int[m[i] for i in c if m[i] isa Int], Int[i for i in c if m[i] isa Int]]
    display(B)
end</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-DulmageMendelsohn1958"><a class="tag is-link" href="#citeref-DulmageMendelsohn1958">DulmageMendelsohn1958</a>Dulmage, Andrew L., and Nathan S. Mendelsohn. &quot;Coverings of bipartite graphs.&quot; Canadian Journal of Mathematics 10 (1958): 517-534.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lecture7/">« Lecture 7: Numerical and Structural Characterizations for DAEs</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 29 January 2024 03:44">Monday 29 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
