<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lecture 7: Numerical and Structural Characterizations for DAEs · ModelingToolkit Course</title><meta name="title" content="Lecture 7: Numerical and Structural Characterizations for DAEs · ModelingToolkit Course"/><meta property="og:title" content="Lecture 7: Numerical and Structural Characterizations for DAEs · ModelingToolkit Course"/><meta property="twitter:title" content="Lecture 7: Numerical and Structural Characterizations for DAEs · ModelingToolkit Course"/><meta name="description" content="Documentation for ModelingToolkit Course."/><meta property="og:description" content="Documentation for ModelingToolkit Course."/><meta property="twitter:description" content="Documentation for ModelingToolkit Course."/><meta property="og:url" content="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture7/"/><meta property="twitter:url" content="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture7/"/><link rel="canonical" href="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture7/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkit Course</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../syllabus/">Syllabus</a></li><li><a class="tocitem" href="../lecture1/">Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl</a></li><li><a class="tocitem" href="../lecture2/">Lecture 2: Developing high-fidelity models of hydraulic systems</a></li><li class="is-active"><a class="tocitem" href>Lecture 7: Numerical and Structural Characterizations for DAEs</a><ul class="internal"><li><a class="tocitem" href="#Numerical-Integrability-Criterion-for-DAEs"><span>Numerical Integrability Criterion for DAEs</span></a></li><li><a class="tocitem" href="#Structural-Analysis"><span>Structural Analysis</span></a></li><li><a class="tocitem" href="#Structural-Integrability-Criterion-for-DAEs"><span>Structural Integrability Criterion for DAEs</span></a></li><li><a class="tocitem" href="#Consistency-Solvability-Criterion-for-DAEs"><span>Consistency Solvability Criterion for DAEs</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Lecture 7: Numerical and Structural Characterizations for DAEs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lecture 7: Numerical and Structural Characterizations for DAEs</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitCourse" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitCourse/blob/main/docs/src/lectures/lecture7.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Lecture-7:-Numerical-and-Structural-Characterizations-for-DAEs"><a class="docs-heading-anchor" href="#Lecture-7:-Numerical-and-Structural-Characterizations-for-DAEs">Lecture 7: Numerical and Structural Characterizations for DAEs</a><a id="Lecture-7:-Numerical-and-Structural-Characterizations-for-DAEs-1"></a><a class="docs-heading-anchor-permalink" href="#Lecture-7:-Numerical-and-Structural-Characterizations-for-DAEs" title="Permalink"></a></h1><h2 id="Numerical-Integrability-Criterion-for-DAEs"><a class="docs-heading-anchor" href="#Numerical-Integrability-Criterion-for-DAEs">Numerical Integrability Criterion for DAEs</a><a id="Numerical-Integrability-Criterion-for-DAEs-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-Integrability-Criterion-for-DAEs" title="Permalink"></a></h2><p>There are both differential equations and algebraic equations in acausal models. Thus, a generic acausal model is a system of differential-algebraic equations (DAEs). In general, additional processing steps are required to simulate DAEs. To see this more clearly, we will analyze the implicit Euler algorithm which is the most basic form of both Runge-Kutta and linear multistep methods for DAEs.</p><p>Given the DAE of the form</p><p class="math-container">\[\begin{equation}
0 = F(u&#39;(t), u(t), p, t),
\end{equation}\]</p><p>where <span>$F: (\mathbb{R}^n, \mathbb{R}^n, \mathbb{R}^m, \mathbb{R}) \rightarrow \mathbb{R}^n$</span>. The implicit Euler solves for <span>$u(t+h)$</span> from</p><p class="math-container">\[\begin{equation}
0 = F\left(\frac{\hat{u}(t+h) - u(t)}{h},\; \hat{u}(t+h),\; p,\; t+h\right),
\end{equation}\]</p><p>with fixed <span>$t, h, p$</span>, and <span>$u(t)$</span>.</p><p>Numerically, we use Newton&#39;s method to solve potentially nonlinear equations by iteratively solving the best approximating linear equations (i.e., the Jacobian of the nonlinear function with respect to the unknowns) to refine an initial guess. By the chain rule, we have</p><p class="math-container">\[\begin{equation}
\frac{\partial F}{\partial u} = \frac{1}{h}F_{u&#39;} + F_{u}.
\end{equation}\]</p><p>The Newton iteration is then</p><p class="math-container">\[\begin{align}
\frac{\partial F}{\partial u} \Delta^{[i]} &amp;= F\left(\frac{\hat{u}^{[i]}(t+h) - u(t)}{h}, \hat{u}^{[i]}(t+h), p, t+h\right) \\
\hat{u}^{[i+1]} &amp;= \hat{u}^{[i]} - \Delta^{[i]},
\end{align}\]</p><p>where <span>$\{\cdot\}^{[i]}$</span> denotes the iteration variable at the <span>$i$</span>-th iteration. Thus, for the implicit Euler algorithm to work, <span>$\lambda F_{u&#39;} + F_{u}$</span> has to be non-singular for sufficiently small <span>$\lambda\in\mathbb{R}$</span>. In fact, this conclusion holds for all linear multistep methods and Runge-Kutta methods, that is, they all need to solve an iteration matrix of the form <span>$\lambda F_{u&#39;} + F_{u}$</span>. Curious readers can check this <a href="https://github.com/SciML/DiffEqDevMaterials/blob/master/newton/output/main.pdf">development documentation</a> on how the Newton iteration is set up for all the other cases. Formally, the <em>numerical integrability criterion</em> is</p><p class="math-container">\[\begin{equation}
\forall u, u&#39;, \exists \lambda &gt; 0, \det(\lambda F_{u&#39;} + F_{u}) \ne 0.
\end{equation}\]</p><h2 id="Structural-Analysis"><a class="docs-heading-anchor" href="#Structural-Analysis">Structural Analysis</a><a id="Structural-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Structural-Analysis" title="Permalink"></a></h2><p>The above criterion is too hard to verify at compile time, since we do not yet know the exact values to solve the DAE. To make it computationally easier to check, we can change the <span>$\forall$</span> to <span>$\exists$</span>, which is</p><p class="math-container">\[\begin{equation}
\exists u, u&#39;, \lambda &gt; 0, \det(\lambda F_{u&#39;} + F_{u}) \ne 0,
\end{equation}\]</p><p>so that we only need to validate a single instance. To make the criterion even easier to check, we introduce the following definitions.</p><div class="admonition is-category-definition"><header class="admonition-header">Sparse Matrix</header><div class="admonition-body"><p>A sparse matrix is a matrix that could contain structural zeros. Structural zeros are entries that are zero by construction denoted by <span>$\hat{0}$</span>. We call an entry structural nonzero if it is not a structural zero. We also define <span>$\mathbb{F}:=\mathbb{R}\cup\hat{0}$</span>.</p></div></div><div class="admonition is-category-definition"><header class="admonition-header">Incidence Matrix</header><div class="admonition-body"><p>A incidence matrix of the symbolically defined function <span>$f: \mathbb{R}^n \to \mathbb{R}^m$</span> with respect to the indexed set of variables <span>$\{x_{j} \}$</span> is a sparse matrix <span>$M\in\mathbb{F}^{m \times n}$</span> defined by</p><p class="math-container">\[\begin{equation}
M_{ij} := \begin{cases}
1, &amp; \text{if } x_{j} \text{ appears in the expression for computing the
$i$-th output of $f$, i.e. } f(\{x_{j}\})_i \\
\hat{0}, &amp; \text{else}
\end{cases}.
\end{equation}\]</p><p>We use <span>$\mathfrak{I}(f, \{x_j\}) := M$</span> to denote the incidence matrix of <span>$f$</span> with respect to <span>$\{x_j\}$</span>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Structural Zeros</header><div class="admonition-body"><p>For convenience, we will simply use <span>$0$</span> and <span>$\mathbb{R}$</span> when structural zeros are obvious in context.</p></div></div><div class="admonition is-category-definition"><header class="admonition-header">Structurally Non-singular</header><div class="admonition-body"><p>A sparse matrix <span>$A$</span> is structurally non-singular if and only if there exists a set of real numbers when it replaces all the structural nonzero entries, the new matrix <span>$\mathfrak{N}(A)$</span> is numerically non-singular.</p></div></div><div class="admonition is-category-example"><header class="admonition-header">Structurally Non-singular</header><div class="admonition-body"><ul><li><span>$A = \begin{pmatrix} 1 &amp; 1 \\ 1 &amp; 1 \end{pmatrix}$</span> is structurally non-singular but numerically singular because we can replace a nonzero such that we get <span>$\mathfrak{N}(A) = \begin{pmatrix} 1 &amp; 10 \\ 1 &amp; 1 \end{pmatrix}$</span> which is numerically non-singular.</li><li><span>$A = \begin{pmatrix} 1 &amp; 2 &amp; 3\\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \end{pmatrix}$</span> is structurally non-singular but numerically singular because we can replace nonzeros such that we get <span>$\mathfrak{N}(A) = \begin{pmatrix} 10 &amp; 2 &amp; 3\\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 10 \end{pmatrix}$</span> which is numerically non-singular.</li><li><span>$\begin{pmatrix} 1 &amp; 1 \\ \hat{0} &amp; \hat{0} \end{pmatrix}$</span> is structurally singular because <span>$\begin{pmatrix} a &amp; b \\ 0 &amp; 0 \end{pmatrix}$</span> is numerically singular for all real <span>$a$</span> and <span>$b$</span>.</li></ul></div></div><p>Although structurally non-singular is a strictly weaker condition than numerically non-singular, checking it seems to be more difficult on the surface because we need to come up with an example that is numerically non-singular. However, the following powerful theorem gives us a dramatically simpler way of checking if a sparse matrix is structurally non-singular.</p><div class="admonition is-info"><header class="admonition-header">Structurally Non-singularity Theorem</header><div class="admonition-body"><p>A square sparse matrix <span>$A$</span> is structurally non-singular if and only if there exist permutation matrices <span>$P$</span> and <span>$Q$</span> such that all the diagonal entries of <span>$PA$</span> and <span>$AQ$</span> are structural nonzeros.</p><h5>Proof:</h5><ul><li><span>$\Leftarrow$</span>: Suppose <span>$A$</span> is a square sparse matrix such that all diagonal entries of <span>$PA$</span> and <span>$AQ$</span> are structural nonzeros, where <span>$P$</span> and <span>$Q$</span> are permutation matrices. Let <span>$\mathfrak{N}(A) = P^{-1}I$</span> or <span>$\mathfrak{N}(A) = IQ^{-1}$</span> which are numerically non-singular. Thus, <span>$A$</span> is structurally non-singular.</li><li><span>$\Rightarrow$</span>: Suppose <span>$\hat{A}\in\mathbb{R}^{n\times n}$</span> is a square sparse matrix that is structurally non-singular. Let <span>$A = \mathfrak{N} (\hat{A})$</span>, we have <span>$\det(A) \ne 0$</span>. Expanding the definition of the determinant, we have<p class="math-container">\[\begin{equation}
\det(A)=\sum_{\sigma \in S_{n}}\operatorname{sgn}(\sigma)\prod_{i = 1}^n
a_{i,\sigma (i)} \ne 0,
\end{equation}\]</p>where <span>$S_n$</span> denotes the set of all permutations of the set <span>$\{1, 2, ..., n\}$</span> (the symmetric group of order <span>$n$</span>). For <span>$\det(A)\ne 0$</span>, there must exist one <span>$\sigma\in S_n$</span> such that <span>$\prod_{i = 1}^n a_{i,\sigma (i)} \ne 0$</span>. Note that we also have <span>$\prod_{i = 1}^n a_{i,\sigma (i)} = \prod_{i = 1}^n a_{\sigma^{-1}(i), i}$</span>. Thus, the desired <span>$Q$</span> is the permutation matrix corresponding to <span>$\sigma$</span>, and the desired <span>$P$</span> is <span>$Q^{-1}$</span>. <span>$\blacksquare$</span></li></ul></div></div><p>The above condition is equivalent with checking the existence of a perfect matching on the induced bipartite graph of the incidence matrix, and it can be efficiently solved by using the augmenting path algorithm to find the maximum cardinality matching.</p><div class="admonition is-category-definition"><header class="admonition-header">Induced Bipartite Graph</header><div class="admonition-body"><p>Given an incidence matrix <span>$A\in\mathbb{R}^{m\times n}$</span> the induced bipartite graph <span>$(U, V, E)$</span> is a tuple of a set of source vertices <span>$U = \{1, 2, ..., m\}$</span>, a set of destination vertices <span>$V\in \{1, 2, ..., n\}$</span>, and edges between them <span>$E \subseteq U\times V$</span> defined by</p><p class="math-container">\[\begin{equation}
\forall (i, j) \in U\times V, (i, j) \in E \iff A_{i, j} = 1.
\end{equation}\]</p><p>Similarly, the induced bipartite graph of a sparse matrix is the induced bipartite graph of its induced incidence matrix.</p></div></div><div class="admonition is-category-definition"><header class="admonition-header">Bipartite Matching</header><div class="admonition-body"><p>A matching of a bipartite graph <span>$(U, V, E)$</span> is a set <span>$M \subseteq E$</span> where every vertex in <span>$U$</span> and <span>$V$</span> can appear at most once in <span>$M$</span>. A matching <span>$M$</span> is perfect if <span>$|M| = |U| = |V|$</span>. We call an edge in a matching matched, otherwise, free. It is often more convenient to interpret matching as the function <span>$m: U \to (V \cup \emptyset)$</span> defined by</p><p class="math-container">\[\begin{equation}
x \mapsto \cup \{y | (x, y) \in M\}.
\end{equation}\]</p></div></div><div class="admonition is-info"><header class="admonition-header">Structural Non-singularity and Perfect Matching Equivalence Theorem</header><div class="admonition-body"><p>A sparse matrix <span>$A\in\mathbb{R}^{m\times n}$</span> is structurally non-singular if and only if its induced bipartite graph has a perfect matching.</p></div></div><div class="admonition is-category-definition"><header class="admonition-header">Augmenting Path</header><div class="admonition-body"><p>Given a particular matching, an alternating path is a sequence of adjacent edges that alternate between being matched and free. In particular, an augmenting path is a alternating path that starts and ends with free edges.</p></div></div><div class="admonition is-info"><header class="admonition-header">Augmenting Path Algorithm for Finding a Maximum Cardinality Matching</header><div class="admonition-body"><p>Input: bipartite graph <span>$G = (U, V, E)$</span>.</p><p>Output: matching <span>$M$</span>.</p><pre><code class="language-julia hljs">M = []
for each u in U
    p ← find an augmenting path w.r.t. M that starts with u
    if p === nothing
        continue
    else
        add all free edges of p to M
        remove all matched edges of p from M
    end
end</code></pre><p>Note that by the definition of augmenting paths, whenever <span>$p$</span> is not <code>nothing</code> in the above algorithm, we increase the cardinality of <span>$M$</span> by <span>$1$</span>. We will assert without a proof that the above algorithm outputs a maximum cardinality matching, and in particular, if <span>$p$</span> is <code>nothing</code> for a source vertex <span>$u$</span>, then no maximum cardinality matching contains an edge that starts with <span>$u$</span>. More details of this algorithm including the search algorithm of an augmenting path are available in the original Pantelides paper <sup class="footnote-reference"><a id="citeref-Pantelides1988" href="#footnote-Pantelides1988">[Pantelides1988]</a></sup>.</p><p>Note that a perfect matching for <span>$G$</span> exists if and only if a maximum cardinality matching <span>$M$</span> satisfies <span>$|M| = |U| = |V|$</span>.</p></div></div><h2 id="Structural-Integrability-Criterion-for-DAEs"><a class="docs-heading-anchor" href="#Structural-Integrability-Criterion-for-DAEs">Structural Integrability Criterion for DAEs</a><a id="Structural-Integrability-Criterion-for-DAEs-1"></a><a class="docs-heading-anchor-permalink" href="#Structural-Integrability-Criterion-for-DAEs" title="Permalink"></a></h2><p>To utilize the structural analysis framework, we need weaken the integrability criterion further from</p><p class="math-container">\[\begin{equation}
\exists u, u&#39;, \lambda &gt; 0, \det(\lambda F_{u&#39;} + F_{u}) \ne 0,
\end{equation}\]</p><p>to the <em>structural integrability criterion</em></p><p class="math-container">\[\begin{equation}
\mathfrak{I}(\mathfrak{I}(F, \{u_i&#39;\}) + \mathfrak{I}(F, \{u_i\})) \text{ is
structurally non-singular.}
\end{equation}\]</p><h2 id="Consistency-Solvability-Criterion-for-DAEs"><a class="docs-heading-anchor" href="#Consistency-Solvability-Criterion-for-DAEs">Consistency Solvability Criterion for DAEs</a><a id="Consistency-Solvability-Criterion-for-DAEs-1"></a><a class="docs-heading-anchor-permalink" href="#Consistency-Solvability-Criterion-for-DAEs" title="Permalink"></a></h2><p>Consider the DAE system</p><p class="math-container">\[\begin{equation}
F(\{x&#39;, y&#39;\}, \{x, y\}, t) =
\begin{pmatrix}
f_1(x, t) \\
f_2(x&#39;, y&#39;, t)
\end{pmatrix} = 0,
\end{equation}\]</p><p>where <span>$f_1$</span> and <span>$f_2$</span> are some arbitrary smooth functions. We have</p><p class="math-container">\[\begin{equation}
\mathfrak{I}(F, \{x&#39;, y&#39;\}) = \begin{pmatrix}
0 &amp; 0 \\
1 &amp; 1
\end{pmatrix},\quad
\mathfrak{I}(F, \{x, y\}) = \begin{pmatrix}
1 &amp; 0 \\
0 &amp; 0
\end{pmatrix}.
\end{equation}\]</p><p>Thus,</p><p class="math-container">\[\begin{equation}
\mathfrak{I}(\mathfrak{I}(F, \{u_i&#39;\}) + \mathfrak{I}(F, \{u_i\})) =
\begin{pmatrix}
1 &amp; 0 \\
1 &amp; 1
\end{pmatrix}
\end{equation}\]</p><p>is structurally non-singular, which means that the DAE system is structurally integrable.</p><p>However, solving for a consistent initial condition <span>$u(t_0)$</span> and <span>$u&#39;(t_0)$</span> is not as simple as simply solving for <span>$F(u&#39;(t_0), u(t_0), t_0) = 0$</span>. Because given a general DAE in the form of <span>$F(u&#39;, u, p, t) = 0$</span>, all its total time derivatives are also valid constraints, i.e.</p><p class="math-container">\[\begin{align}
F(u&#39;, u, p, t) &amp;= 0 \\
F&#39;(u&#39;&#39;, u&#39;, u, p, t) &amp;= 0  \\
F&#39;&#39;(u&#39;&#39;&#39;, u&#39;&#39;, u&#39;, u, p, t) &amp;= 0 \\
    &amp;\vdots \nonumber
\end{align}\]</p><p>For the above example, we can differentiate the <span>$f_1$</span> equation once and get</p><p class="math-container">\[\begin{equation}
\begin{pmatrix}
f&#39;_1(x&#39;, t) \\
f_2(x&#39;, y&#39;, t)
\end{pmatrix} = 0.
\end{equation}\]</p><p>Note that differentiating <span>$f&#39;_1$</span> and <span>$f_2$</span> further is not necessary because we will not get additional constraints for the states (<span>$u(t)$</span> and <span>$u&#39;(t)$</span>) of the DAE system.</p><p>We need a more systematic way of knowing when differentiating <span>$F$</span> does not add new &quot;information&quot; into the system. First, let&#39;s develop a characterization on the variables. Let <span>$z=\{z_i\}$</span> be the set of the highest order derivative variables, and let <span>$\lambda = \{\lambda_i\}$</span> contain the rest of the variables. Note that <span>$z$</span> and <span>$\lambda$</span> must be disjoint. Therefore, DAEs can then be written as</p><p class="math-container">\[0 = F(z, \lambda, p, t) \\\]</p><p>Differentiating the above equation gives us</p><p class="math-container">\[F_z z&#39; + F_\lambda \lambda&#39; + F_t = 0\]</p><p>Note that <span>$z&#39; = \{z&#39;_i\}$</span> contains all the new terms generated by the differentiation, as it contains variables with higher order derivatives than before. Rearranging terms, we get</p><p class="math-container">\[F_z z&#39; = -F_\lambda \lambda&#39; - F_t.\]</p><p>When <span>$F_z$</span> is non-singular, we can use old terms to explicitly solve for <span>$z&#39;$</span>, so we don&#39;t generate genuinely new equations, and this is the <em>numerical consistency solvability criterion</em>. Therefore, we only add new equations to the system if and only if <span>$F_z$</span> is singular. It&#39;s wasteful to differentiate the entire system until the matrix is invertible; we can differentiate a minimal subset of equations to make <span>$F_z$</span> non-singular.</p><p>Similarly, the <em>structural consistency solvability criterion</em> is then</p><p class="math-container">\[\mathfrak{I}(F, z) \text{ is structurally non-singular.}\]</p><p>For the above system, the differentiated system has</p><p class="math-container">\[\mathfrak{I}(F, \{x&#39;, y&#39;\}) = \begin{pmatrix}
1 &amp; 0 \\
1 &amp; 1
\end{pmatrix},\]</p><p>which is structurally non-singular. Thus, the differentiated system satisfies the structural consistency solvability criterion.</p><p>Note that the sparsity pattern of <span>$\mathfrak{I}(\mathfrak{I}(F, \{u_i&#39;\}) + \mathfrak{I}(F, \{u_i\}))$</span> is always a subset of <span>$\mathfrak{I}(F, z)$</span> for arbitrary systems. The structural consistency solvability criterion is stronger than the structural integrability criterion, so we just check the structural consistency solvability criterion.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Pantelides1988"><a class="tag is-link" href="#citeref-Pantelides1988">Pantelides1988</a>Pantelides, Constantinos C. &quot;The consistent initialization of differential-algebraic systems.&quot; SIAM Journal on scientific and statistical computing 9.2 (1988): 213-231.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lecture2/">« Lecture 2: Developing high-fidelity models of hydraulic systems</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 11 January 2024 21:46">Thursday 11 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
