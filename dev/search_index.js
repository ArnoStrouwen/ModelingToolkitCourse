var documenterSearchIndex = {"docs":
[{"location":"syllabus/#ModelingToolkitCourse","page":"Syllabus","title":"ModelingToolkitCourse","text":"","category":"section"},{"location":"syllabus/","page":"Syllabus","title":"Syllabus","text":"[!NOTE] This course is running live as part of MIT's IAP! For details see:18.S191 Special Subject in Mathematics: Composable System Modeling and Its CompilationDates: Jan 9 - Feb 2Time: MWF 11-12Location: 2-135","category":"page"},{"location":"syllabus/","page":"Syllabus","title":"Syllabus","text":"Traditionally, modeling physical systems often requires a deep understanding of the physics and equations of motions or states, simplifying the differential equations using conservation laws and constraints, and finally implementing simplified equations in a scientific computing language to numerically solve them. However, this workflow is tedious and not expressive. A simple change in the underlying physical system often requires a complete re-derivation of the simplified equations. A composable modeling system frees domain experts from the time-consuming derivation, simplification, and implementation by allowing them to model each physical component separately and hierarchically, thereby enabling them to build more accurate and complex models without compromising the simulation performance. In this course, we will dive into the practice of implementing composable physical models and the compilation process of the model system using the ModelingToolkit.jl acausal modeling framework in Julia. Students will learn the mathematics and numerical methods behind solving industry-scale models, covering topics such as differential-algebraic equations (DAEs), modern techniques in implicit integrators (backwards differentiation formulae (BDFs)), symbolic manipulation of equations via techniques like Pantelides algorithm and tearing of nonlinear systems, and more. Applications for solving real-world problems like modeling battery systems of electric vehicles, efficient control of hydraulic and HVAC systems, and more will be used to demonstrate how these techniques are used in industrial settings.","category":"page"},{"location":"syllabus/#Syllabus","page":"Syllabus","title":"Syllabus","text":"","category":"section"},{"location":"syllabus/","page":"Syllabus","title":"Syllabus","text":"Prerequisites: While this course will be mixing ideas from symbolic computing, numerical differential equations, and topics from mechanical engineering, no one in the course is expected to have covered all of these topics before. Understanding of calculus, linear algebra, and programming is essential. The course is considered self-contained starting from the basic building blocks of undergraduate differential equations. Problem sets will involve use of Julia, a Matlab-like environment (little or no prior experience required; you will learn as you go), for doing acausal modeling via the ModelingToolkit.jl system.","category":"page"},{"location":"syllabus/","page":"Syllabus","title":"Syllabus","text":"Textbook & Other Reading: There is no textbook for this course. For a textbook that covers the practical parts of doing modeling and simulation in an acausal way, Michael Tiller's \"Modelica by Example\" is a good reference (see https://mbe.modelica.university/). For a textbook that covers the algorithms of acausal modeling compilers, there is no recommended textbook and lecture notes will be supplied as a primary source.","category":"page"},{"location":"syllabus/","page":"Syllabus","title":"Syllabus","text":"Grading: The final project proposal (due January 15th) is 25%, and 75% for the final project (due February 2nd). Final projects will be submitted electronically via email.","category":"page"},{"location":"syllabus/#Final-Project","page":"Syllabus","title":"Final Project","text":"","category":"section"},{"location":"syllabus/","page":"Syllabus","title":"Syllabus","text":"The final project can take two forms: ","category":"page"},{"location":"syllabus/","page":"Syllabus","title":"Syllabus","text":"Developing an acausal model of some real-world system. \nImplementation and analysis of a new acausal modeling compiler feature. \nImplementation and analysis of numerical methods for acausal models.","category":"page"},{"location":"syllabus/","page":"Syllabus","title":"Syllabus","text":"A final project proposal is due January 19th and the final project is due on the last day of the course. The last day will be final project presentations where the work is demonstrated to the class.","category":"page"},{"location":"syllabus/","page":"Syllabus","title":"Syllabus","text":"The final project's deliverable can take two different forms:","category":"page"},{"location":"syllabus/","page":"Syllabus","title":"Syllabus","text":"A final project writeup: a 5-10 page paper using the style template from the SIAM Journal on Numerical Analysis (or similar) explaining what was done, along with a Github repository package with the components of the model and docs/tests which demonstrate the successful composed model.\nA pull request to one of the libraries (ModelingToolkit, ModelingToolkitStandardLibrary, OrdinaryDiffEq, NonlinearSolve, etc.). For this version of the project, it is sufficient to supply a pull request to MTK/MSL with a description of the feature being implemented, tests of the transformation, and documentation showcasing its correct action on test models.","category":"page"},{"location":"syllabus/","page":"Syllabus","title":"Syllabus","text":"We expect the work to be roughly the same for the two routes, where the 1st would entail more theory and mathematical writeup while the latter is more focused on code and documentation. Note that any project considering doing a new acausal modeling feature should heavily consider doing the pull request route as writing a toy acausal modeling compiler within the timeframe of the course is likely to be unsuccessful.","category":"page"},{"location":"syllabus/","page":"Syllabus","title":"Syllabus","text":"Note that many of these projects are starter projects towards publications. If you're interested in continuing this work after the IAP towards a publication, please discuss during the project selection page so the project can be appropriately scoped.","category":"page"},{"location":"syllabus/#Project-Type-1-Ideas:-Developing-an-Acausal-Model-of-A-Real-World-System","page":"Syllabus","title":"Project Type 1 Ideas: Developing an Acausal Model of A Real-World System","text":"","category":"section"},{"location":"syllabus/","page":"Syllabus","title":"Syllabus","text":"The following sources can be used as inspiration:","category":"page"},{"location":"syllabus/","page":"Syllabus","title":"Syllabus","text":"Modelica \"other\" libraries (https://modelica.org/libraries/) \nModelica Standard Library (https://github.com/modelica/ModelicaStandardLibrary)","category":"page"},{"location":"syllabus/#Project-Type-2-Ideas:-Implementation-and-analysis-of-a-new-acausal-modeling-compiler-feature","page":"Syllabus","title":"Project Type 2 Ideas: Implementation and analysis of a new acausal modeling compiler feature","text":"","category":"section"},{"location":"syllabus/","page":"Syllabus","title":"Syllabus","text":"Automated Laplace and Fourier transforms\nAutomated function transformation of observables (i.e. log-transform states to enforce positivity)\nSymbolic generation of sensitivity analysis equations (https://github.com/SciML/ModelingToolkit.jl/issues/39)\nLamperti transformation of stochastic differential equations (https://github.com/SciML/ModelingToolkit.jl/issues/140)\nAutomated conversion of distributed delay equations into ODEs (https://github.com/SciML/ModelingToolkit.jl/issues/45)\nSpecialized nonlinear solvers based on strongly connected components\nInline integration (https://people.inf.ethz.ch/fcellier/Pubs/OO/esm_95.pdf)\nAutomated detection of events from discontinuities in the ODE/DAE definition\nPolynomial chaos expansions for fast uncertainty quantification\nDCP on OptimizationSystem to automatically transform nonlinear optimization problems to convex optimization problems (http://cvxr.com/cvx/doc/dcp.html)\nCommon subexpression elimination in Symbolic code generation\nExtendable C code generation maps from Symbolics\nDirect-quadrature-zero transformation for multibody systems and robotics (https://en.wikipedia.org/wiki/Direct-quadrature-zero_transformation)\nPryce's algorithm for DAE index reduction (https://link.springer.com/article/10.1023/A:1021998624799, https://inria.hal.science/hal-03104030v2/document)","category":"page"},{"location":"syllabus/#Project-Type-3-Ideas:-Implementation-and-analysis-of-numerical-methods-for-acausal-models","page":"Syllabus","title":"Project Type 3 Ideas: Implementation and analysis of numerical methods for acausal models","text":"","category":"section"},{"location":"syllabus/","page":"Syllabus","title":"Syllabus","text":"Adaptive order Radau methods (https://www.sciencedirect.com/science/article/pii/S037704279900134X)\nParallel Rosenbrock and FIRK methods\nHandling the difficulties of BDFs in DAE systems (i.e. handling known deficiencies in the DFBDF algorithm)\nNew time stepping schema for Rosenbrock methods for DAE interpolation performance\nInvestigation of nonlinear solver globalization schemes for difficult DAE initialization problems","category":"page"},{"location":"syllabus/#Tentative-Schedule","page":"Syllabus","title":"Tentative Schedule","text":"","category":"section"},{"location":"syllabus/","page":"Syllabus","title":"Syllabus","text":"January 10th: Introduction to the course, Guest lecture: Brad Carman, introduction to acausal modeling for physical systems with ModelingToolkit\nJanuary 12th: Guest lecture: Brad Carman, developing high-fidelity models of hydraulic systems \nJanuary 15th: Martin Luther King Day!\nJanuary 17th: Real numerical methods for implicit equations and stiff ordinary differential equations (ODEs), i.e., Jacobian-free Newton-Krylov, adaptive time stepping, dense output, sparse automatic differentiation, event handling.\nJanuary 18th (Make up day for MLK day): Continuing discussion of stiff ODEs and onto numerical methods for differential-algebraic equations (DAEs). Rosenbrock methods, Backwards-Differentiation Formulae (BDF), fully-implicit Runge-Kutta methods.\nJanuary 19th: Finishing the discussion on stiff ODEs and DAEs. If time allows, discussion of handling inverse problems (parameter estimation), adjoint methods, uncertainty quantification, and the connections to reverse-mode AD.\nJanuary 22nd: Discussion and interactive workshop on debugging difficult stiff ODE/DAE models (featuring Brad Carman and Yingbo Ma).\nJanuary 24th: Guest Lecture: Yingbo Ma. How acausal model compilers work: index reduction. Pantelides algorithm, dummy derivatives, and demonstrations.\nJanuary 26th: Guest Lecture: Yingbo Ma. How acausal model compilers work: Tearing of nonlinear systems and alias elimination.\nJanuary 29th: Guest Lecture: Yingbo Ma. How acausal model compilers work: Loop rerolling, specialized optimizations for multibody systems, and other generated code robustness and performance optimizations.\nJanuary 31st: TBD based on what is not sufficiently covered earlier in the course.\nFebruary 2nd: Final project presentations!","category":"page"},{"location":"lectures/lecture7/#Lecture-7:-Numerical-and-Structural-Characterizations-for-DAEs","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"","category":"section"},{"location":"lectures/lecture7/#Numerical-Integrability-Criterion-for-DAEs","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Numerical Integrability Criterion for DAEs","text":"","category":"section"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"There are both differential equations and algebraic equations in acausal models. Thus, a generic acausal model is a system of differential-algebraic equations (DAEs). In general, additional processing steps are required to simulate DAEs. To see this more clearly, we will analyze the implicit Euler algorithm which is the most basic form of both Runge-Kutta and linear multistep methods for DAEs.","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"Given the DAE of the form","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"beginequation\n0 = F(u(t) u(t) p t)\nendequation","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"where F (mathbbR^n mathbbR^n mathbbR^m mathbbR) rightarrow mathbbR^n. The implicit Euler solves for u(t+h) from","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"beginequation\n0 = Fleft(frachatu(t+h) - u(t)h hatu(t+h) p t+hright)\nendequation","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"with fixed t h p, and u(t).","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"Numerically, we use Newton's method to solve potentially nonlinear equations by iteratively solving the best approximating linear equations (i.e., the Jacobian of the nonlinear function with respect to the unknowns) to refine an initial guess. By the chain rule, we have","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"beginequation\nfracpartial Fpartial u = frac1hF_u + F_u\nendequation","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"The Newton iteration is then","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"beginalign\nfracpartial Fpartial u Delta^i = Fleft(frachatu^i(t+h) - u(t)h hatu^i(t+h) p t+hright) \nhatu^i+1 = hatu^i - Delta^i\nendalign","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"where cdot^i denotes the iteration variable at the i-th iteration. Thus, for the implicit Euler algorithm to work, lambda F_u + F_u has to be non-singular for sufficiently small lambdainmathbbR. In fact, this conclusion holds for all linear multistep methods and Runge-Kutta methods, that is, they all need to solve an iteration matrix of the form lambda F_u + F_u. Curious readers can check this development documentation on how the Newton iteration is set up for all the other cases. Formally, the numerical integrability criterion is","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"beginequation\nforall u u exists lambda  0 det(lambda F_u + F_u) ne 0\nendequation","category":"page"},{"location":"lectures/lecture7/#Structural-Analysis","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Structural Analysis","text":"","category":"section"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"The above criterion is too hard to verify at compile time, since we do not yet know the exact values to solve the DAE. To make it computationally easier to check, we can change the forall to exists, which is","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"beginequation\nexists u u lambda  0 det(lambda F_u + F_u) ne 0\nendequation","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"so that we only need to validate a single instance. To make the criterion even easier to check, we introduce the following definitions.","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"definition: Sparse Matrix\nA sparse matrix is a matrix that could contain structural zeros. Structural zeros are entries that are zero by construction denoted by hat0. We call an entry structural nonzero if it is not a structural zero. We also define mathbbF=mathbbRcuphat0.","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"definition: Incidence Matrix\nA incidence matrix of the symbolically defined function f mathbbR^n to mathbbR^m with respect to the indexed set of variables x_j  is a sparse matrix MinmathbbF^m times n defined bybeginequation\nM_ij = begincases\n1  textif  x_j text appears in the expression for computing the\ni-th output of f ie  f(x_j)_i \nhat0  textelse\nendcases\nendequationWe use mathfrakI(f x_j) = M to denote the incidence matrix of f with respect to x_j.","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"note: Structural Zeros\nFor convenience, we will simply use 0 and mathbbR when structural zeros are obvious in context.","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"definition: Structurally Non-singular\nA sparse matrix A is structurally non-singular if and only if there exists a set of real numbers when it replaces all the structural nonzero entries, the new matrix mathfrakN(A) is numerically non-singular.","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"example: Structurally Non-singular\nA = beginpmatrix 1  1  1  1 endpmatrix is structurally non-singular but numerically singular because we can replace a nonzero such that we get mathfrakN(A) = beginpmatrix 1  10  1  1 endpmatrix which is numerically non-singular.\nA = beginpmatrix 1  2  3 4  5  6  7  8  9 endpmatrix is structurally non-singular but numerically singular because we can replace nonzeros such that we get mathfrakN(A) = beginpmatrix 10  2  3 4  5  6  7  8  10 endpmatrix which is numerically non-singular.\nbeginpmatrix 1  1  hat0  hat0 endpmatrix is structurally singular because beginpmatrix a  b  0  0 endpmatrix is numerically singular for all real a and b.","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"Although structurally non-singular is a strictly weaker condition than numerically non-singular, checking it seems to be more difficult on the surface because we need to come up with an example that is numerically non-singular. However, the following powerful theorem gives us a dramatically simpler way of checking if a sparse matrix is structurally non-singular.","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"info: Structurally Non-singularity Theorem\nA square sparse matrix A is structurally non-singular if and only if there exist permutation matrices P and Q such that all the diagonal entries of PA and AQ are structural nonzeros.Proof:Leftarrow: Suppose A is a square sparse matrix such that all diagonal entries of PA and AQ are structural nonzeros, where P and Q are permutation matrices. Let mathfrakN(A) = P^-1I or mathfrakN(A) = IQ^-1 which are numerically non-singular. Thus, A is structurally non-singular.\nRightarrow: Suppose hatAinmathbbR^ntimes n is a square sparse matrix that is structurally non-singular. Let A = mathfrakN (hatA), we have det(A) ne 0. Expanding the definition of the determinant, we have\nbeginequation\ndet(A)=sum_sigma in S_noperatornamesgn(sigma)prod_i = 1^n\na_isigma (i) ne 0\nendequation\nwhere S_n denotes the set of all permutations of the set 1 2  n (the symmetric group of order n). For det(A)ne 0, there must exist one sigmain S_n such that prod_i = 1^n a_isigma (i) ne 0. Note that we also have prod_i = 1^n a_isigma (i) = prod_i = 1^n a_sigma^-1(i) i. Thus, the desired Q is the permutation matrix corresponding to sigma, and the desired P is Q^-1. blacksquare","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"The above condition is equivalent with checking the existence of a perfect matching on the induced bipartite graph of the incidence matrix, and it can be efficiently solved by using the augmenting path algorithm to find the maximum cardinality matching.","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"definition: Induced Bipartite Graph\nGiven an incidence matrix AinmathbbR^mtimes n the induced bipartite graph (U V E) is a tuple of a set of source vertices U = 1 2  m, a set of destination vertices Vin 1 2  n, and edges between them E subseteq Utimes V defined bybeginequation\nforall (i j) in Utimes V (i j) in E iff A_i j = 1\nendequationSimilarly, the induced bipartite graph of a sparse matrix is the induced bipartite graph of its induced incidence matrix.","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"definition: Bipartite Matching\nA matching of a bipartite graph (U V E) is a set M subseteq E where every vertex in U and V can appear at most once in M. A matching M is perfect if M = U = V. We call an edge in a matching matched, otherwise, free. It is often more convenient to interpret matching as the function m U to (V cup emptyset) defined bybeginequation\nx mapsto cup y  (x y) in M\nendequation","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"info: Structural Non-singularity and Perfect Matching Equivalence Theorem\nA sparse matrix AinmathbbR^mtimes n is structurally non-singular if and only if its induced bipartite graph has a perfect matching.","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"definition: Augmenting Path\nGiven a particular matching, an alternating path is a sequence of adjacent edges that alternate between being matched and free. In particular, an augmenting path is a alternating path that starts and ends with free edges.","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"info: Augmenting Path Algorithm for Finding a Maximum Cardinality Matching\nInput: bipartite graph G = (U V E).Output: matching M.M = []\nfor each u in U\n    p ← find an augmenting path w.r.t. M that starts with u\n    if p === nothing\n        continue\n    else\n        add all free edges of p to M\n        remove all matched edges of p from M\n    end\nendNote that by the definition of augmenting paths, whenever p is not nothing in the above algorithm, we increase the cardinality of M by 1. We will assert without a proof that the above algorithm outputs a maximum cardinality matching, and in particular, if p is nothing for a source vertex u, then no maximum cardinality matching contains an edge that starts with u. More details of this algorithm including the search algorithm of an augmenting path are available in the original Pantelides paper [Pantelides1988].Note that a perfect matching for G exists if and only if a maximum cardinality matching M satisfies M = U = V.","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"[Pantelides1988]: Pantelides, Constantinos C. \"The consistent initialization of differential-algebraic systems.\" SIAM Journal on scientific and statistical computing 9.2 (1988): 213-231.","category":"page"},{"location":"lectures/lecture7/#Structural-Integrability-Criterion-for-DAEs","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Structural Integrability Criterion for DAEs","text":"","category":"section"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"To utilize the structural analysis framework, we need weaken the integrability criterion further from","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"beginequation\nexists u u lambda  0 det(lambda F_u + F_u) ne 0\nendequation","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"to the structural integrability criterion","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"beginequation\nmathfrakI(mathfrakI(F u_i) + mathfrakI(F u_i)) text is\nstructurally non-singular\nendequation","category":"page"},{"location":"lectures/lecture7/#Consistency-Solvability-Criterion-for-DAEs","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Consistency Solvability Criterion for DAEs","text":"","category":"section"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"Consider the DAE system","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"beginequation\nF(x y x y t) =\nbeginpmatrix\nf_1(x t) \nf_2(x y t)\nendpmatrix = 0\nendequation","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"where f_1 and f_2 are some arbitrary smooth functions. We have","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"beginequation\nmathfrakI(F x y) = beginpmatrix\n0  0 \n1  1\nendpmatrixquad\nmathfrakI(F x y) = beginpmatrix\n1  0 \n0  0\nendpmatrix\nendequation","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"Thus,","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"beginequation\nmathfrakI(mathfrakI(F u_i) + mathfrakI(F u_i)) =\nbeginpmatrix\n1  0 \n1  1\nendpmatrix\nendequation","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"is structurally non-singular, which means that the DAE system is structurally integrable.","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"However, solving for a consistent initial condition u(t_0) and u(t_0) is not as simple as simply solving for F(u(t_0) u(t_0) t_0) = 0. Because given a general DAE in the form of F(u u p t) = 0, all its total time derivatives are also valid constraints, i.e.","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"beginalign\nF(u u p t) = 0 \nF(u u u p t) = 0  \nF(u u u u p t) = 0 \n    vdots nonumber\nendalign","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"For the above example, we can differentiate the f_1 equation once and get","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"beginequation\nbeginpmatrix\nf_1(x t) \nf_2(x y t)\nendpmatrix = 0\nendequation","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"Note that differentiating f_1 and f_2 further is not necessary because we will not get additional constraints for the states (u(t) and u(t)) of the DAE system.","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"We need a more systematic way of knowing when differentiating F does not add new \"information\" into the system. First, let's develop a characterization on the variables. Let z=z_i be the set of the highest order derivative variables, and let lambda = lambda_i contain the rest of the variables. Note that z and lambda must be disjoint. Therefore, DAEs can then be written as","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"0 = F(z lambda p t) ","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"Differentiating the above equation gives us","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"F_z z + F_lambda lambda + F_t = 0","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"Note that z = z_i contains all the new terms generated by the differentiation, as it contains variables with higher order derivatives than before. Rearranging terms, we get","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"F_z z = -F_lambda lambda - F_t","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"When F_z is non-singular, we can use old terms to explicitly solve for z, so we don't generate genuinely new equations, and this is the numerical consistency solvability criterion. Therefore, we only add new equations to the system if and only if F_z is singular. It's wasteful to differentiate the entire system until the matrix is invertible; we can differentiate a minimal subset of equations to make F_z non-singular.","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"Similarly, the structural consistency solvability criterion is then","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"mathfrakI(F z) text is structurally non-singular","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"For the above system, the differentiated system has","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"mathfrakI(F x y) = beginpmatrix\n1  0 \n1  1\nendpmatrix","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"which is structurally non-singular. Thus, the differentiated system satisfies the structural consistency solvability criterion.","category":"page"},{"location":"lectures/lecture7/","page":"Lecture 7: Numerical and Structural Characterizations for DAEs","title":"Lecture 7: Numerical and Structural Characterizations for DAEs","text":"Note that the sparsity pattern of mathfrakI(mathfrakI(F u_i) + mathfrakI(F u_i)) is always a subset of mathfrakI(F z) for arbitrary systems. The structural consistency solvability criterion is stronger than the structural integrability criterion, so we just check the structural consistency solvability criterion.","category":"page"},{"location":"lectures/lecture2/#Lecture-2:-Developing-high-fidelity-models-of-hydraulic-systems","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"","category":"section"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Why focus on hydraulics?  The answer is essentially hydraulic modelling is really hard (in numerical computing terms, hydraulic models are often referred to as \"stiff\" ODE's, which require more rigorous solvers from standard ODE's).  Solving the challenges of modeling hydraulics is applicable to the numerical modeling challenges of all other domains.  Let's first start with the concept of compressibility.  Often we think of a liquid as incompressible, imagine attempting to \"squeeze\" water, it can be done but takes some very high forces.  Therefore, if the model in question won't be solving a problem with high forces, it can be assumed incompressible.  However, most hydrulic industrial models will involve high forces, this is precisely the area where most hydraulic machines are used.  ","category":"page"},{"location":"lectures/lecture2/#Compressibility","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Compressibility","text":"","category":"section"},{"location":"lectures/lecture2/#Density","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Density","text":"","category":"section"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Density is simply mass over volume","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"rho = mV","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Given a volume and mass of liquid, if the volume were to change from V_0 to V, we know that the pressure would increase, and since the mass in this case was constant, the density will increase as well.","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"(Image: volume change)","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"The change in pressure for an isothermal compressible process is typically given as","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Delta p = -beta fracDelta VV_0","category":"page"},{"location":"lectures/lecture2/#Calculating-Density-as-a-Function-of-Pressure","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Calculating Density as a Function of Pressure","text":"","category":"section"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Substituting Delta p and Delta V","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"p - p_0 = -beta fracV - V_0V_0","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"substituting V = m  rho","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"p - p_0 = -beta (1 - rhorho_0)  ","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Solving for rho","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"rho = rho_0 (1 + (p - p_0)beta)","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Taking a known rho_0 when p_0 is 0 (at gage pressure), simplifies to","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"rho = rho_0 (1 + pbeta) ","category":"page"},{"location":"lectures/lecture2/#Change-in-Mass","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Change in Mass","text":"","category":"section"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Conservation of mass gives us","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"m_in - m_out = m_s ","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"The stored mass of oil is simply","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"m_s = rho V ","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Taking the derivative gives us the rate of mass change","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"dotm_in - dotm_out = fracdelta (rho V)delta t ","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Here is where the standard hydraulic modeling often makes a simplification.  ","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Correct Derivation (1):  ","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"fracdelta (rho V)delta t = dotrho V + rho dotV ","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Standard Practice[1] (2):  ","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"colorred fracdelta (rho V)delta t = dotrho V + rho_0 dotV   ","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Given dotrho = rho_0 (dotp  beta), and q = dotmrho_0 the above is often written as","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"colorred q_in - q_out = (dotp  beta) V + dotV ","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"[1]: See simscape hydraulic chamber.  Note the deprecation warning moving to isothermal liquid library which uses the correct derivation.","category":"page"},{"location":"lectures/lecture2/#Example","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Example","text":"","category":"section"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Problem Definition - Given:","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"M = 10000 kg\nA = 900 cm^2 \nrho_0 = 876 kgm^3\nbeta = 12e9 Pam^3\ng = 9807 ms^2","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"(Image: example)","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Find the mass flow rate (dotm) that provides a sinusodial output of x:","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"x(t) = amp cdot sin(2πtf) + x_0","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"There are 3 fundamental equations needed to solve this problem, (1) Mass balance: ","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"dotm = dotrho cdot V + rho cdot dotV","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"where V is the cylinder volume =x cdot A","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"(2) Newton's law:","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"m cdot ddotx = p*A - m*g","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"And the (3) Density equation.  ","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"The variables of this system are x, p, rho, and dotm.  By including 1 input condition that gives 4 equations and 4 variables to be solved.  Now, the problem to be solved is, \"what is the mass flow rate, dotm, that gives the desired sinusodial x?  There are 2 ways to go about finding the correct dotm.  The first is to guess.  We know that mass flow rate thru a pipe is equal to ","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"dotm = rho baru A","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"where baru is the average flow velocity thru cross section A.  We can assume that baru approx dotx.  Therefore we have","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"dotm = rho cdot dotx cdot A","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"The second way to find the correct dotm is to solve for it directly.  We can do this by simply supplying the target x function as the input to the system.  In this example we will do both and compare the results.","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"To solve this in ModelingToolkit.jl, let's start by defining our parameters and x function","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"using ModelingToolkit\nusing DifferentialEquations\nusing Symbolics\nusing Plots\n\n@parameters t\nD = Differential(t)\n\n# parameters -------\npars = @parameters begin\n    r₀ = 876 #kg/s\n    β = 1.2e9 #Pa\n    A = 0.01 #m²\n    x₀ = 1.0 #m\n    M = 10_000 #kg\n    g = 9.807 #m/s²\n    amp = 5e-2 #m\n    f = 15 #Hz    \nend\n\ndt = 1e-4 #s\nt_end = 0.2 #s\ntime = 0:dt:t_end\n\nx_fun(t,amp,f) = amp*sin(2π*t*f) + x₀","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Now, to supply dotm we need an dotx function.  This can be automatically generated for us with Symbolics.jl","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"ẋ_fun = build_function(expand_derivatives(D(x_fun(t,amp,f))), t, amp, f; expression=false)","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"As can be seen, we get a cos function as expected taking the derivative of sin.  Now let's build the variables and equations of our system.  The base equations are generated in a function so we can easily compare the correct derivation of mass balance (density_type = r(t)) with the standard practice (density_type = r₀).","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"vars = @variables begin\n    x(t) = x₀\n    ẋ(t)\n    ẍ(t)\n    p(t) = M*g/A #Pa\n    ṁ(t)\n    r(t)\n    ṙ(t)\nend \n\nfunction get_base_equations(density_type) \n    \n    eqs = [\n        D(x) ~ ẋ \n        D(ẋ) ~ ẍ\n        D(r) ~ ṙ\n\n        r ~ r₀*(1 + p/β)\n\n        ṁ ~ ṙ*x*A + (density_type)*ẋ*A\n        M*ẍ ~ p*A - M*g\n    ]\n\n    return eqs\nend","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Note: we've only specified the initial values for the known states of x and p.  We will find the additional unknown initial conditions before solving.  Now we have 7 variables defined and only 6 equations, missing the final driving input equation.  Let's build 3 different cases:","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"case 1: mass flow guess using standard practice mass flow balance","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"eqs_ṁ1 = [\n    get_base_equations(r₀)...\n    ṁ ~ ẋ_fun(t,amp,f)*A*r # (4) Input - mass flow guess\n]","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"case 2: mass flow guess using correct compressibility equation","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"eqs_ṁ2 = [\n    get_base_equations(r)...\n    ṁ ~ ẋ_fun(t,amp,f)*A*r # (4) Input - mass flow guess\n]","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"case 3: solution","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"eqs_x = [\n    get_base_equations(r)...\n    x ~ x_fun(t,amp,f) # (4) Input - target x \n]","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Now we have 3 sets of equations, let's construct the systems and solve.  If we start with the 3rd system with the target x input, notice that the structural_simplify step outputs a system with 0 equations!","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"@named odesys_x = ODESystem(eqs_x, t, vars, pars)\nsys_x = structural_simplify(odesys_x)","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"What this means is ModelingToolkit.jl has found that this model can be solved entirely analytically.  The full system of equations has been moved to what is called \"observables\", which can be obtained using the observed() function","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"observed(sys_x)","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"note: dummy derivatives\nSome of the observables have a ˍt appended to the name.  These are called dummy derivatives, which are a consequence of the algorithm to reduce the system DAE index.  ","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"This system can still be \"solved\" using the same steps to generate an ODESolution which allows us to easily obtain any calculated observed state.","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"prob_x = ODEProblem(sys_x, [], (0, t_end))\nsol_x = solve(prob_x; saveat=time)\nplot(sol_x; idxs=ṁ)","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Now let's solve the other system and compare the results. ","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"@named odesys_ṁ1 = ODESystem(eqs_ṁ1, t, vars, pars)\nsys_ṁ1 = structural_simplify(odesys_ṁ1)","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Notice that now, with a simple change of the system input variable, structural_simplify() outputs a system with 4 states to be solved.  We can find the initial conditions needed for these states from sol_x and solve.","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"u0 = [sol_x[s][1] for s in states(sys_ṁ1)]\nprob_ṁ1 = ODEProblem(sys_ṁ1, u0, (0, t_end))\nsol_ṁ1 = solve(prob_ṁ1)","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"The resulting mass flow rate required to hit the target x position can be seen to be completely wrong.  This is the large impact that compressibility can have when high forces are involved.","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"plot(sol_ṁ1; idxs=ṁ, label=\"guess\", ylabel=\"ṁ\")\nplot!(sol_x; idxs=ṁ, label=\"solution\")","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"If we now solve for case 2, we can study the impact the compressibility derivation","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"@named odesys_ṁ2 = ODESystem(eqs_ṁ2, t, vars, pars)\nsys_ṁ2 = structural_simplify(odesys_ṁ2)\nprob_ṁ2 = ODEProblem(sys_ṁ2, u0, (0, t_end))\nsol_ṁ2 = solve(prob_ṁ2)","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"As can be seen, a significant error forms between the 2 cases. ","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"plot(sol_x; idxs=x, label=\"solution\", ylabel=\"x\")\nplot!(sol_ṁ1; idxs=x, label=\"case 1: r₀\")\nplot!(sol_ṁ2; idxs=x, label=\"case 2: r\")","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"plot(time, (sol_ṁ1(time)[x] .- sol_ṁ2(time)[x])/1e-3, label=\"x\", ylabel=\"error (case 1 - case 2) [mm]\", xlabel=\"t [s]\")","category":"page"},{"location":"lectures/lecture2/#Practice-Problem","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Practice Problem","text":"","category":"section"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Now let's re-create this example using components from the ModelingToolkitStandardLibrary.jl.  It can be shown that by connecting Mass and Volume components that the same exact result is achieved.  The important thing is to pay very close attention to the initial conditions.  ","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"import ModelingToolkitStandardLibrary.Mechanical.Translational as T\nimport ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible as IC\nimport ModelingToolkitStandardLibrary.Blocks as B\n\nusing DataInterpolations\nmass_flow_fun = LinearInterpolation(sol_x[ṁ], sol_x.t)\n\ninclude(\"volume.jl\") # <-- missing Volume component from MTKSL (will be released in new version) \n\nfunction MassVolume(; name, dx, drho, dm)\n\n    pars = @parameters begin\n        A = 0.01 #m²\n        x₀ = 1.0 #m\n        M = 10_000 #kg\n        g = 9.807 #m/s²\n        amp = 5e-2 #m\n        f = 15 #Hz   \n        p_int=M*g/A\n        dx=dx\n        drho=drho\n        dm=dm\n    end\n    vars = []\n    systems = @named begin\n        fluid = IC.HydraulicFluid(; density = 876, bulk_modulus = 1.2e9)\n        mass = T.Mass(;v=dx,m=M,g=-g)\n        vol = Volume(;area=A, x=x₀, p=p_int, dx, drho, dm) # <-- missing Volume component from MTKSL (will be released in new version) \n        mass_flow = IC.MassFlow(;p_int)\n        mass_flow_input = B.TimeVaryingFunction(;f = mass_flow_fun)\n    end\n\n    eqs = [\n        connect(mass.flange, vol.flange)\n        connect(vol.port, mass_flow.port)\n        connect(mass_flow.dm, mass_flow_input.output)\n        connect(mass_flow.port, fluid)\n    ]\n\n    return ODESystem(eqs, t, vars, pars; systems, name)\nend\n\ndx = sol_x[ẋ][1]\ndrho = sol_x[ṙ][1]\ndm = sol_x[ṁ][1]\n\n@named odesys = MassVolume(; dx, drho, dm)\n\nsys = structural_simplify(odesys)\n\nprob = ODEProblem(sys, [], (0, t_end))\nsol=solve(prob)\n\nplot(sol; idxs=sys.vol.x, linewidth=2)\nplot!(sol_x; idxs=x)","category":"page"},{"location":"lectures/lecture2/#Momentum-Balance","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Momentum Balance","text":"","category":"section"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"The next challenging aspect of hydraulic modeling is modeling flow through a pipe, which for compressible flow requires resolving the momentum balance equation. To derive the momentum balance we can draw a control volume (cv) in a pipe with area A, as shown in the figure below, and apply Newton's second law.  Across this control volume from x_1 to x_2 the pressure will change from p_1 to p_2.  Assuming this is written for an acausal component we put nodes at p_1 to p_2 which will have equal mass flow dotm entering and exiting the cv[2].","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"[2]: The Modelica Standard Library combines the mass and momentum balance to the same base class, therefore, mass flow in and out of the cv is not equal, which introduces an additional term to the lhs of the momentum balance:  $ \\frac{\\partial \\left( \\rho u^2 A \\right) }{\\partial x}  $  ","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Now taking the sum of forces acting on the cv we have the pressure forces at each end as well as the viscous drag force from the pipe wall and the body force from gravity.  The sum of forces is equal to the product of mass (rho V) and flow acceleration (dotu).   ","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"    rho V dotu = p_1 A_1 - p_2 A_2 - F_viscous + rho V g","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"note: Project Idea\nthe current implementation of this component in the ModelingToolkitStandardLibrary.jl does not include gravity force for this makes initialization challenging and will take some work to implement.","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"The density rho is an average of rho_1 and rho_2.  The velocity is also taken as an average of u_1 and u_2","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"u_1 = fracdotmrho_1 A","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"u_2 = fracdotmrho_2 A","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"(Image: momentum balance)","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"note: Conservation of Momentum\n","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"the term \\rho V \\dot{u} introduces what is referd to as fluid inertia.  This is what resolves the pressure wave propagation through a pipe.  A classic wave propagation example in pipes is the \"water hammer\" effect.  The full derivation for the flow velocity derivative is when deriving in 2 dimensions is ","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"   fracD textVDt = fracpartial textVpartial t + fracpartial textVpartial x u + fracpartial textVpartial z w\n   \n   where textv is the velocity vector u and w are the flow components in x and y directions  In the ModelingToolkitStandardLibraryjl this assumption is taken\n   math\n   rho V fracD textVDt approx fracpartial dotmpartial t\n     \n   \n\n note Project Idea\n    Implement a more detailed Conservation of Momentum using the standard derivation  One idea is to implement the MethodOfLinesjl to provide the derivative in x\n    \n\n Pipe Component\nTo model a pipe for compressible flow we can combine the mass balance and momentum balance components to give both mass storage and flow resistance  Furthermore to provide a more accurate model that allows for wave propagation we can discretize the volume connected by node of equal pressure and mass flow  The diagram below shows an example of discretizing with 3 mass balance volumes and 2 momentum balance resistive elements  Note the Modelica Standard Library does this in a different way by combining the mass and momentum balance in a single base class  \n\npipe(imgpipesvg)\n\n\n Dynamic Volume Component\nBoth Modelica and SimScape model the actuator component with simply a uniform pressure volume component  The Modelica library defines the base fluids class around the assumption of constant length (see Object-Oriented Modeling of Thermo-Fluid Systems(httpselibdlrde119881otter2003-modelica-fluidpdf)) and therefore adapting to a component that changes length is not possible  But in cases with long actuators with high dynamics the pressure is not at all uniform therefore this detail cannot be ignored  Therefore adding in the momentum balance to provide flow resistance and fluid inertia are necessary  The diagram below shows the design of a DynamicVolume component which includes both mass and momentum balance in addition to discretization by volume  The discretization is similar to the pipe except the scheme becomes a bit more complicated with the moving wall (x)  As the volume shrinks the control volumes will also shrink however not in unison but one at a time  In this way as the moving wall closes the flow will come from the first volume cv1 and travel thru the full size remaining elements (cv2 cv3 etc)  After the first component length drops to zero the next element will then start to shrink  \n\nvolume(imgvolumesvg)\n\nThis design has a flaw unfortunately expanding the system for N=3 gives \n\neqs1(imgvolume_eq1png)\n\nWhat happens when transitioning from one cv to the next if the moving wall velocity is significant then an abrupt change occurs due to the rho_i dotx term  This creates an unstable condition for the solver and results in poor qualityaccuracy  To resolve this problem the mass balance equation is split into 2 parts mass balance 1  2 \n","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"math \\text{mass balance 1: } \\dot{m}/A = \\dot{\\rho} x","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"math \\text{mass balance 2: } \\dot{m}/A = \\rho \\dot{x} ```","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"The below diagram explains how this component is constructed","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"(Image: dynamic volume)","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"Now the flows are simplified and are more numerically stable.  The acausal connections then handle the proper summing of flows.","category":"page"},{"location":"lectures/lecture2/","page":"Lecture 2: Developing high-fidelity models of hydraulic systems","title":"Lecture 2: Developing high-fidelity models of hydraulic systems","text":"(Image: eqs2)","category":"page"},{"location":"#ModelingToolkit-Course","page":"Home","title":"ModelingToolkit Course","text":"","category":"section"},{"location":"lectures/lecture1/#Lecture-1:-Introduction-to-acausal-modeling-for-physical-systems-with-ModelingToolkit.jl","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"","category":"section"},{"location":"lectures/lecture1/#Background","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Background","text":"","category":"section"},{"location":"lectures/lecture1/#Julia","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Julia","text":"","category":"section"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"This course will use Julia as the fundamental tool to solve numerical problems.  ModelingToolkit.jl is a package written in pure Julia and leverages the fundamental technologies of symbolic math from Symbolics.jl, numerical solvers from DifferentialEquations.jl, and automatic differentiation from ForwardDiff.jl.  To demonstrate an introduction to these technologeies, lets focus on one of the most fundamental engineering problems: the mass-spring-damper.  For now, let's leave the mass out of the system to avoid the 2nd derivative term and assume a non-linear spring (k cdot x^15)","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"(Image: )","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"This system can be represented by the ordinary differential equation (ODE):","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"d cdot dotx + k cdot x^15 = F","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"To solve this in Julia we can apply finite differencing dotx_i = fracx_i - x_i-1Delta t and Newton's method.  Here we solve for the first time step...","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"using ForwardDiff\nusing Plots\n\nd=1      # damping coefficient [N/(m/s)]\nk=1000   # spring stiffness [N/m]\nΔt=1e-3  # time step [s]\nF = 100  # input force [N]\n\nfunction f(xᵢ, xᵢ₋₁)\n\n    ẋᵢ = (xᵢ - xᵢ₋₁)/Δt     # finite difference derivative\n    lhs = d*ẋᵢ + k*xᵢ^1.5   # lhs --> left hand side\n    rhs = F                 # rhs --> right hand side\n\n    return lhs - rhs     # equation --> lhs = rhs, residual --> 0 = lhs - rhs\nend\n\n# Newton's Method\n# first time step (i=2)\nxᵢ₋₁ = 0.0\nxᵢ = xᵢ₋₁ #<-- guess\ng(xᵢ) = f(xᵢ, xᵢ₋₁)  # g(xᵢ) turns f(xᵢ, xᵢ₋₁) into a function of only xᵢ\n# Run Newton Iterations\nxᵢ -= g(xᵢ)/ForwardDiff.derivative(g, xᵢ) # iteration 1\nxᵢ -= g(xᵢ)/ForwardDiff.derivative(g, xᵢ) # iteration 2\nxᵢ -= g(xᵢ)/ForwardDiff.derivative(g, xᵢ) # iteration 3","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"note: about derivatives\nWe can get the derivative for f from automatic differentiation using ForwardDiff.derivative (or using ForwardDiff.jacobian for a system of equations).","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"To solve for a series of time steps, we can simply update x and run again for each time step Δt.  This is a simple form of the Implicit/Backwards Euler method.","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"tol = 1e-3\nx = zeros(10)\nfor i=2:10\n    g(xᵢ) = f(xᵢ, x[i-1])\n    Δx = Inf\n    while abs(Δx) > tol\n        Δx = g(x[i])/ForwardDiff.derivative(g, x[i]) \n        x[i] -= Δx\n    end\nend\n\nplot(x; ylabel=\"x [m]\", xlabel=\"time step\")","category":"page"},{"location":"lectures/lecture1/#DifferentialEquations.jl","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"DifferentialEquations.jl","text":"","category":"section"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"For this simple problem it's easy enough to implement the Newton method and solve directly, however it's possible to instead use the solvers from DifferentialEquations.jl.  To do this, we simply need to defined a NonlinearProblem by supplying the function f of the form f(up) where:","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"u is the variables (scalar or vector)\np is the parameters (scalar or vector)","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"In this case u and p correspond to xᵢ and xᵢ₋₁, respectively.  This is referred to as the \"out-of-place\" form, where each call to f allocates, it is also possible to define f(duup) as \"in-place\" form that gives du as a pre-allocated memory space to mutate.  ","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Then we can solve by specifying the method, in this case we specify NewtonRaphson to implement Newton's method.","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"using DifferentialEquations\n\np  = xᵢ₋₁ = 0.0 # initial condition if i=2, x[1]=0 \nu0 = xᵢ = xᵢ₋₁  # guess value for x[i]\n\nprob = NonlinearProblem(f, u0, p)\nsol=solve(prob, NewtonRaphson(); abstol=tol)","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Note:  we get exactly the same result for the first time step.","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"To solve for a series of time steps, we can now use the remake function to update the initial guess u0 and parameter p and generate an updated NonlinearProblem efficiently (i.e. with minimal allocations).","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"x = zeros(10)\nfor i=2:10\n    prob′ = remake(prob; u0=x[i], p=x[i-1])\n    sol = solve(prob′, NewtonRaphson(); abstol=tol)\n    x[i] = sol[]\nend\nplot(x; ylabel=\"x [m]\", xlabel=\"time step\")","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"This approach requires the use of finite differencing and building a solution vector of solves for each time step, which was done only for demonstration purposes.  Since this problem is an ODE, it can and should be solved directly with an ODE solver.  To do this with DifferentialEquations.jl, we simply re-arrange the equation to solve explicitly for the derivative of x, giving the form fracpartial upartial t = f(upt).  In this case we have","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"dotx= fracF - k cdot x^15d","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"function du_dt(u,p,t)\n    F, k, d = p\n    x = u\n    return (F - k*x^1.5)/d\nend\nu0 = 0.0            # initial value for x\np = [F, k, d]       # parameters\ntspan = (0.0, 0.01) # solution time span\nprob = ODEProblem(du_dt, u0, tspan, p) \nsol = solve(prob)\nplot(sol; xlabel=\"time [s]\", ylabel=\"x [m]\")","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"In some cases, it may not be so easy to rearrange the equations in such a way to provide an ODE form.  We can also solve the problem in another way: Differential Algebraic Equations (DAE) form.  Here we have a mix of differential and algebraic equations.  A mass matrix is used to specify which equations are differential vs. algebraic.  Note that we are now solving for both x and dotx and therefore need to supply initial conditions for each.  To satisfy the system at time 0 with x=0, we can see that dotx = fracFd.  ","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"note: about initial conditions\nTechnically the initial condition u0 can be either a guess or explicit.  By default it is treated as a guess value and an algorithm is used to solve for a u0 that satisfies the system at the initial time.  See the documentation for the initializealg keyword for more information.","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"function du_dt(u,p,t)\n    F, k, d = p\n    x, ẋ = u\n    \n    eqs = [\n        ẋ                       # D(x) = ẋ\n        (d*ẋ + k*x^1.5) - (F)   #    0 = ( lhs ) - ( rhs )\n    ]\n\n    return eqs\nend\n\nfmm = ODEFunction(du_dt; mass_matrix=[1 0; 0 0])\nu0 = [0.0, F/d] # initial value for x,ẋ\nprob = ODEProblem(fmm, u0, tspan, p)\nsol = solve(prob)\nplot(sol; idxs=1, xlabel=\"time [s]\", ylabel=\"x [m]\")","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Now, maybe we would like to know the 2nd derivative of x.  It should be easy enough to simply provide this in our function and solve.","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"function du_dt(u,p,t)\n    F, k, d = p\n    x, ẋ, ẍ = u\n    \n    eqs = [\n        ẋ                       # D(x) = ẋ\n        ẍ                       # D(ẋ) = ẍ\n        (d*ẋ + k*(x^1.5)) - (F)   #    0 = ( lhs ) - ( rhs )\n    ]\n\n    return eqs\nend\n\nfmm = ODEFunction(du_dt; mass_matrix=[1 0 0;0 1 0;0 0 0])\nu0 = [0.0, F/d, 0.0] # initial value for x, ẋ, ẍ\nprob = ODEProblem(fmm, u0, tspan, p)\nsol = solve(prob);\nsol.retcode","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Now we get a DtLessThanMin code, meaning the solver failed to converge.  The reason for this is an index problem, our algebraic constraint equation does not use the 2nd derivative term ddotx.  To solve index problems, the algrebraic constraints must be differentiated until they contain the highest order terms.  This can be done as an exercise, however, this provides a perfect segue to the tool that can make all this easier and automatic: ModelingToolkit.jl","category":"page"},{"location":"lectures/lecture1/#ModelingToolkit.jl","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"ModelingToolkit.jl","text":"","category":"section"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"ModelingToolkit.jl uses symbolic math from Symbolics.jl to provide automatic index reduction and problem simplification to provide the optimal form for a numerical solver.  To define the same problem attempted previously in ModelingToolkit.jl, we first specify an independent variable t and it's differential operator","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"using ModelingToolkit\n@variables t\nD = Differential(t)\nnothing # hide","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"note: about Symbolics\nNote that t is now a symbolic term.  Writing sin(t) does not compute anything, it simply represents the function symbolically.  Writing D(sin(t)) then represents the derivative of sin(t) with respect to t.  To compute the derivative, we can use the function expand_derivativesD(sin(t)) |> expand_derivatives","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"To assemble a problem symbolically for ModelingToolkit.jl, we can define our variables and equations like","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"pars = @parameters F=100 d=1 k=1000\nvars = @variables x(t)=0.0 ẋ(t)=F/d ẍ(t)=0.0\neqs = [\n    D(x) ~ ẋ\n    D(ẋ) ~ ẍ\n    d*ẋ + k*x^1.5 ~ F\n]\nnothing # hide","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Note the variables are defined as a function of the independent variable t and given initial conditions which are captured in the variable vars.  The equations are then defined using the tilde ~ operator, which represents the equation equality.  This information is then fed to an ODESystem constructor and simplified using the structural_simplify function.  ","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@named odesys = ODESystem(eqs, t, vars, pars)\nsys = structural_simplify(odesys)","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"As can be seen, the 3 equation system is simplified down to 1 equation.  To see the solved states and equations we can use the respective functions","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"states(sys)","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Now we are solving for only x(t) with the equation:","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"equations(sys)","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"This seems correct, but what is ẋ(t)?  This variable has been moved to the observables of the system, which are terms which can be computed algebraicly.","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"observed(sys)","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Notice how the 2nd derivative term ẍ(t) has been automatically determined from the symbolic derivative of ẋ(t).","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"We can now assembly a problem and solve it.  The initial conditions do not need to be supplied here because the sys contains the variable defaults from vars.  The solution object sol can now be indexed symbolically from any symbol of the system regardless if it's a solved variable, observable, or even a parameter.  This way, if for example doing a batch of simulations, each respective solution object can easily retrieve all respective information about the simulation.","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"u0 = [] # <-- used to override defaults of ODESystem variables\np = [] # <-- used to override defaults of ODESystem parameters\nprob = ODEProblem(sys, u0, tspan, p)\nsol = solve(prob; abstol=tol)\nplot(sol; idxs=ẍ, xlabel=\"time [s]\", ylabel=\"ẍ [m/s^2]\")","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Using ModelingToolkit.jl, the solution can also be indexed by expression, for example plotting the damping and spring force components can be done as so","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"plot(sol; idxs=x^1.5*k, xlabel=\"time [s]\", ylabel=\"force [N]\")\nplot!(sol; idxs=ẋ*d)","category":"page"},{"location":"lectures/lecture1/#Acausal-Component-Based-Modeling","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Acausal - Component Based Modeling","text":"","category":"section"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"ModelingToolkit.jl enables the application of Physical Network Acausal modeling, which is a type of modeling which is component based allowing one to build models by assembling parts together from a library.  The key to how this works is thru a simple rule of how components are connected.  A connection must define at minimum 2 variables (through and across see about connectors for a deeper explanation) which follows the rules:","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"connections can only be made by like connectors (i.e. same pairs of through and across variables from the same physical domain)\nthrough variables sum to zero at connection points\nacross variables are equal at connection points","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Consider a simple mechanical translational system of a mass and damper.  In this domain the through variable is force (f) and the across velocity (v).  We can define the mass component as","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"f_mass = m_mass cdot dotv_mass","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"And the damper component as","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"f_damper = d_damper cdot v_damper","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Based on the rules above, connecting these 2 components together would give the following additional equations","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"beginaligned \n    0 = f_mass + f_damper  \n    v_mass = v_damper \nendaligned  ","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"With simple substitution it can be seen that this gives the expected mass-damper system","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"m cdot dotv + d cdot v = 0","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Let's try this again by defining this system in ModelingToolkit.jl","category":"page"},{"location":"lectures/lecture1/#Connections","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Connections","text":"","category":"section"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"To define a connection in ModelingToolkit.jl we use the @connector macro and specify the through variable with connect = Flow","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@connector MechanicalPort begin\n    v(t)\n    f(t), [connect = Flow]\nend\nnothing # hide","category":"page"},{"location":"lectures/lecture1/#Components","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Components","text":"","category":"section"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"To define a component, we use the @mtkmodel macro and define it's parameters, variables, connection ports, and equations.  The mass component can be defined as","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@mtkmodel Mass begin\n    @parameters begin\n        m = 10\n    end\n    @variables begin\n        v(t)\n        f(t)\n    end\n    @components begin\n        port = MechanicalPort()\n    end\n    @equations begin\n        # connectors\n        port.v ~ v\n        port.f ~ f\n        \n        # physics\n        f ~ m*D(v)\n    end\nend\nnothing # hide","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Now there are 2 tricky issues when defining models at the component level.  First is the number of equations.  How can you know if you've properly defined a base component without having the remaining parts to close the system and ensure you have a matching set of variables and equations?  A general rule of thumb is that a base level component should have an equation number that matches the number of variables + connectors.  The Mass component has 2 variables and 1 connector and therefore 3 equations.","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"The 2nd tricky issue is signs.  To determine this one can draw a diagram like below.  Below the port draw the across variable from left to right (positive) direction.  Then draw the through variable entering the component.  If the arrows point in the same direction, the connection port through variable assignment is positive, if opposing, then the sign should be negative.  ","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"(Image: mass)","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Similarly the damper component is defined as below.  ","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@mtkmodel Damper begin\n    @parameters begin\n        d = 1\n    end\n    @variables begin\n        v(t)\n        f(t)\n    end\n    @components begin\n        port = MechanicalPort()\n    end\n    @equations begin\n        # connectors\n        port.v ~ v\n        port.f ~ f\n        \n        # physics\n        f ~ d*v\n    end\nend\nnothing # hide","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"(Image: single port damper)","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Now the Mass and Damper components can be assembled in a system and connected together (note: the connect equation).  Also note the parameters v, m, and d are defined to expose the properties which can be set as keyword arguments of the same name.  ","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@mtkmodel System begin\n    @parameters begin\n        v\n        m\n        d\n    end\n    @components begin\n        mass = Mass(;v,m)\n        damper = Damper(;v,d)\n    end\n    @equations begin\n        connect(mass.port, damper.port)\n    end\nend\n\n@mtkbuild sys = System(;v=100, m=5, d=3)\nfull_equations(sys)","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"As can be seen we arrive at the same equation as derived previously.  Now it would be easy to define a system that adds a spring, or has a series of connected masses, springs, dampers, etc.  ","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"The Damper component created previously was a little incomplete because it only had one port.  In reality a damper or spring will be connected between 2 objects, for example the car frame and the wheel.  Therefore a proper component will define 2 ports so that the component can be as analogous with real life as possible.  In the example below the component is defined properly with 2 ports.  Note the velocity of the component v is defined as a relative velocity between the 2 ports.  It's easy to understand how this works if it's assumed that port_b is connected to a stationary reference frame.","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@mtkmodel Damper begin\n    @parameters begin\n        d = 1\n    end\n    @variables begin\n        v(t)\n        f(t)\n    end\n    @components begin\n        port_a = MechanicalPort()\n        port_b = MechanicalPort()\n    end\n    @equations begin\n        # connectors\n        (port_a.v - port_b.v) ~ v\n        port_a.f ~ +f\n        port_b.f ~ -f\n        \n        # physics\n        f ~ d*v\n    end\nend\nnothing # hide","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Note the force is drawn now as entering the component on both sides.  For port a the directions align, but for port b the directions are opposing, requiring a sign change: port_b.f ~ -f","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"(Image: damper)","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Now we can do the same for the spring component.  Note that the spring is of course very similar to the damper, but now we need a relative position.  This can be obtained by integrating the port velocities, but how do we integrate in ModelingToolkit.jl?  We want to write the equation","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"x = int v space partial t","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"But we know that this is also true","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"fracpartial xpartial t = v","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"In ModelingToolkit therefore we can \"integrate\" by moving the differential to the appropriate side of the equation.","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@mtkmodel Spring begin\n    @parameters begin\n        k = 100\n    end\n    @variables begin\n        x(t)\n        v(t)\n        f(t)\n    end\n    @components begin\n        port_a = MechanicalPort()\n        port_b = MechanicalPort()\n    end\n    @equations begin\n        # derivatives\n        D(x) ~ v\n\n        # connectors\n        (port_a.v - port_b.v) ~ v\n        port_a.f ~ +f\n        port_b.f ~ -f\n        \n        # physics\n        f ~ k*x\n    end\nend\nnothing # hide","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"(Image: spring)","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"One thing to consider now in the Spring component is the meaning of the spring stretch/compression variable x.  What does it mean if this variable is positive or negative?  It's important to note when reviewing the model output that a positive x means the spring is compressed and vise versa for a negative x.","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Now, if we want to create a full mass-spring-damper system with our new Damper and Spring components, we need to create some boundary conditions, such as a stationary reference and an input force.  Creating a stationary reference in acausal modeling is a bit tricky.  We know that the velocity should be set to zero, as it's stationary.  But what should the force be?  Thinking about Newton's principles, every force on a non-moving object is met with an equal but opposite force.  Therefore we add a variable f to represent this force, which will be part of the solved system solution. ","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@mtkmodel Reference begin\n    @parameters begin\n        \n    end\n    @variables begin\n        f(t)\n    end\n    @components begin\n        port = MechanicalPort()\n    end\n    @equations begin\n        # connectors\n        port.v ~ 0\n        port.f ~ f\n    end\nend\nnothing # hide","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"(Image: reference)","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Finally, considering an input force, we can imagine this to be an invisible hand that pushes with a constant force.  This invisible hand will move with the port with velocity v.  We don't know this velocity, it's a variable that will part of the solved system solution.  ","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@mtkmodel ConstantForce begin\n    @parameters begin\n        f\n    end\n    @variables begin\n        v(t)\n    end\n    @components begin\n        port = MechanicalPort()\n    end\n    @equations begin\n        # connectors\n        port.v ~ v\n        port.f ~ -f  \n    end\nend\nnothing # hide","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Note the sign convention port.f ~ -f.  This is maybe not expected.  To understand why a negative is needed here is because this component is different from the others, there is no physics involved.  The component is instead only a boundary condition, therefore force should be leaving the component rather than entering.","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"(Image: force input)","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Now let's assemble a mass-spring-damper system with the full collection of components.","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@mtkmodel System begin\n    @parameters begin\n        v=0\n        x=0\n        m=100\n        d=10\n        k=1000\n        f=1\n    end\n    @components begin\n        mass = Mass(;v,m)\n        damper = Damper(;v, d)\n        spring = Spring(;v, k, x)\n        ref = Reference()\n        force = ConstantForce(;v,f)\n    end\n    @equations begin\n        connect(mass.port, damper.port_a, spring.port_a, force.port)\n        connect(damper.port_b, spring.port_b, ref.port)\n    end\nend\n\n@mtkbuild sys = System()\nprob = ODEProblem(sys, [], (0, 10))\nsol = solve(prob)\nplot(sol)","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"There's a couple things we can do now to ensure the system is correct.  First, we can look at the equations.","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"full_equations(sys)","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"The first equation (after re-aranging) it can be seen is the classic mass-spring-damper equation.","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"m cdot ddotx + d cdot dotx + k cdot x = f","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"So we know all the signs and equations are set correctly.  Additionally it's easy enough in this case to re-construct the problem directly and solve to check the result.","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"vars = @variables x(t)=0 dx(t)=0 ddx(t)=0\npars = @parameters m=100 d=10 k=1000 F=1\neqs = [\n    D(x) ~ dx\n    D(dx) ~ ddx\n    m*ddx + d*dx + k*x ~ F\n]\n@named odesys = ODESystem(eqs, t, vars, pars)\nsys = structural_simplify(odesys)\nprob = ODEProblem(sys, [], (0,10))\nsol = solve(prob)\nplot(sol)","category":"page"},{"location":"lectures/lecture1/#Systems-and-Sub-Systems","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Systems and Sub-Systems","text":"","category":"section"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"Acausal modeling allows for an \"object-oriented\" like system that can organize models with hierarchy.  Let's say for example we want to make a part that is a collection of the mass, spring, damper into a single system.  The MassSpringDamper component below shows how this is possible.  As can be seen, this is nearly the same system we generated previously, except no boundary conditions are given, instead 2 MechanicalPort's are added and connected to the component parts.  These connection points are now exposed and can be connected to other components.","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@mtkmodel MassSpringDamper begin\n    @parameters begin\n        m\n        k\n        d\n        v\n        x\n    end\n    @components begin\n        port_a = MechanicalPort()\n        port_b = MechanicalPort()\n        mass = Mass(;m,v)\n        damper = Damper(;d,v)\n        spring = Spring(;k,v,x)\n    end\n    @equations begin\n        connect(mass.port, damper.port_a, spring.port_a, port_a)\n        connect(damper.port_b, spring.port_b, port_b)\n    end\nend\nnothing # hide","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"As an example, the MassSpringDamper component can be connected in series to make a complex system.  One can imagine then how this enables easy construction of complex models that can be quickly modified, extremely useful for the application of model based design.  ","category":"page"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"@mtkmodel System begin\n    @parameters begin\n        v = 0\n        x = 0\n    end\n    @components begin\n        msd1 = MassSpringDamper(;m = 10, d = 1, k = 1000, v, x)\n        msd2 = MassSpringDamper(;m = 20, d = 2, k = 2000, v, x)\n        msd3 = MassSpringDamper(;m = 30, d = 3, k = 3000, v, x)\n        ref = Reference()\n        force = ConstantForce(;f=1,v=0)\n    end\n    @equations begin\n        connect(force.port, msd1.port_a)\n        connect(msd1.port_b, msd2.port_a)\n        connect(msd2.port_b, msd3.port_a)\n        connect(msd3.port_b, ref.port)\n    end\nend\n\n@mtkbuild sys = System()\nprob = ODEProblem(sys, [], (0, 2))\nsol = solve(prob)\nplot(sol; idxs=[sys.msd1.spring.x, sys.msd2.spring.x, sys.msd3.spring.x])","category":"page"},{"location":"lectures/lecture1/#Practice-Exercise","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Practice Exercise","text":"","category":"section"},{"location":"lectures/lecture1/","page":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","title":"Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl","text":"The current solution shows how the springs are compressed.  How can the model be updated to show the absolute positions of the springs?  For example, if each spring starts at an unstreched length of 10mm, connected together they will form a collection of 30mm with masses inbetween.  Update the model to show the absolute position of each mass in time.","category":"page"}]
}
