<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lecture 2: Developing high-fidelity models of hydraulic systems · ModelingToolkit Course</title><meta name="title" content="Lecture 2: Developing high-fidelity models of hydraulic systems · ModelingToolkit Course"/><meta property="og:title" content="Lecture 2: Developing high-fidelity models of hydraulic systems · ModelingToolkit Course"/><meta property="twitter:title" content="Lecture 2: Developing high-fidelity models of hydraulic systems · ModelingToolkit Course"/><meta name="description" content="Documentation for ModelingToolkit Course."/><meta property="og:description" content="Documentation for ModelingToolkit Course."/><meta property="twitter:description" content="Documentation for ModelingToolkit Course."/><meta property="og:url" content="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture2/"/><meta property="twitter:url" content="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture2/"/><link rel="canonical" href="https://docs.sciml.ai/ModelingToolkitCourse/stable/lectures/lecture2/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkit Course</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../syllabus/">Syllabus</a></li><li><a class="tocitem" href="../lecture1/">Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl</a></li><li class="is-active"><a class="tocitem" href>Lecture 2: Developing high-fidelity models of hydraulic systems</a><ul class="internal"><li><a class="tocitem" href="#Compressibility"><span>Compressibility</span></a></li><li><a class="tocitem" href="#Momentum-Balance"><span>Momentum Balance</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Lecture 2: Developing high-fidelity models of hydraulic systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lecture 2: Developing high-fidelity models of hydraulic systems</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitCourse" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitCourse/blob/main/docs/src/lectures/lecture2.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Lecture-2:-Developing-high-fidelity-models-of-hydraulic-systems"><a class="docs-heading-anchor" href="#Lecture-2:-Developing-high-fidelity-models-of-hydraulic-systems">Lecture 2: Developing high-fidelity models of hydraulic systems</a><a id="Lecture-2:-Developing-high-fidelity-models-of-hydraulic-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Lecture-2:-Developing-high-fidelity-models-of-hydraulic-systems" title="Permalink"></a></h1><p>Why focus on hydraulics?  The answer is essentially hydraulic modelling is really hard (in numerical computing terms, hydraulic models are often referred to as &quot;stiff&quot; ODE&#39;s, which require more rigorous solvers from standard ODE&#39;s).  Solving the challenges of modeling hydraulics is applicable to the numerical modeling challenges of all other domains.  Let&#39;s first start with the concept of <em>compressibility</em>.  Often we think of a liquid as incompressible, imagine attempting to &quot;squeeze&quot; water, it can be done but takes some very high forces.  Therefore, if the model in question won&#39;t be solving a problem with high forces, it can be assumed incompressible.  However, most hydrulic industrial models will involve high forces, this is precisely the area where most hydraulic machines are used.  </p><h2 id="Compressibility"><a class="docs-heading-anchor" href="#Compressibility">Compressibility</a><a id="Compressibility-1"></a><a class="docs-heading-anchor-permalink" href="#Compressibility" title="Permalink"></a></h2><h3 id="Density"><a class="docs-heading-anchor" href="#Density">Density</a><a id="Density-1"></a><a class="docs-heading-anchor-permalink" href="#Density" title="Permalink"></a></h3><p>Density is simply mass over volume</p><p class="math-container">\[\rho = m/V\]</p><p>Given a volume and mass of liquid, if the volume were to change from <span>$V_0$</span> to <span>$V$</span>, we know that the pressure would increase, and since the mass in this case was constant, the density will increase as well.</p><p><img src="../../img/VolumeChange.svg" alt="volume change"/></p><p>The change in pressure for an isothermal compressible process is typically given as</p><p class="math-container">\[\Delta p = -\beta \frac{\Delta V}{V_0}\]</p><h3 id="Calculating-Density-as-a-Function-of-Pressure"><a class="docs-heading-anchor" href="#Calculating-Density-as-a-Function-of-Pressure">Calculating Density as a Function of Pressure</a><a id="Calculating-Density-as-a-Function-of-Pressure-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-Density-as-a-Function-of-Pressure" title="Permalink"></a></h3><p>Substituting <span>$\Delta p$</span> and <span>$\Delta V$</span></p><p class="math-container">\[p - p_0 = -\beta \frac{V - V_0}{V_0}\]</p><p>substituting <span>$V = m / \rho$</span></p><p class="math-container">\[p - p_0 = -\beta (1 - \rho/\rho_0)  \]</p><p>Solving for <span>$\rho$</span></p><p class="math-container">\[\rho = \rho_0 (1 + (p - p_0)/\beta)\]</p><p>Taking a known <span>$\rho_0$</span> when <span>$p_0$</span> is 0 (at gage pressure), simplifies to</p><p class="math-container">\[\rho = \rho_0 (1 + p/\beta) \]</p><h3 id="Change-in-Mass"><a class="docs-heading-anchor" href="#Change-in-Mass">Change in Mass</a><a id="Change-in-Mass-1"></a><a class="docs-heading-anchor-permalink" href="#Change-in-Mass" title="Permalink"></a></h3><p>Conservation of mass gives us</p><p class="math-container">\[m_{in} - m_{out} = m_s \]</p><p>The stored mass of oil is simply</p><p class="math-container">\[m_s = \rho V \]</p><p>Taking the derivative gives us the rate of mass change</p><p class="math-container">\[\dot{m}_{in} - \dot{m}_{out} = \frac{\delta (\rho V)}{\delta t} \]</p><p>Here is where the standard hydraulic modeling often makes a simplification.  </p><p>Correct Derivation (1):  </p><p class="math-container">\[\frac{\delta (\rho V)}{\delta t} = \dot{\rho} V + \rho \dot{V} \]</p><p>Standard Practice<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> (2):  </p><p class="math-container">\[\color{red} \frac{\delta (\rho V)}{\delta t} = \dot{\rho} V + \rho_0 \dot{V}   \]</p><p>Given <span>$\dot{\rho} = \rho_0 (\dot{p} / \beta)$</span>, and <span>$q = \dot{m}/\rho_0$</span> the above is often written as</p><p class="math-container">\[\color{red} q_{in} - q_{out} = (\dot{p} / \beta) V + \dot{V} \]</p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>Problem Definition - Given:</p><ul><li><span>$M = 10,000 kg$</span></li><li><span>$A = 900 cm^2$</span> </li><li><span>$\rho_0 = 876 kg/m^3$</span></li><li><span>$\beta = 1.2e9 Pa/m^3$</span></li><li><span>$g = 9.807 m/s^2$</span></li></ul><p><img src="../../img/Example.svg" alt="example"/></p><p>Find the mass flow rate (<span>$\dot{m}$</span>) that provides a sinusodial output of <span>$x$</span>:</p><p class="math-container">\[x(t) = amp \cdot sin(2πtf) + x_0\]</p><p>There are 3 fundamental equations needed to solve this problem, <strong>(1) Mass balance</strong>: </p><p class="math-container">\[\dot{m} = \dot{\rho} \cdot V + \rho \cdot \dot{V}\]</p><p>where <span>$V$</span> is the cylinder volume <span>$=x \cdot A$</span></p><p><strong>(2) Newton&#39;s law</strong>:</p><p class="math-container">\[m \cdot \ddot{x} = p*A - m*g\]</p><p>And the <strong>(3) Density equation</strong>.  </p><p>The variables of this system are <span>$x$</span>, <span>$p$</span>, <span>$\rho$</span>, and <span>$\dot{m}$</span>.  By including 1 input condition that gives 4 equations and 4 variables to be solved.  Now, the problem to be solved is, &quot;what is the mass flow rate, <span>$\dot{m}$</span>, that gives the desired sinusodial <span>$x$</span>?  There are 2 ways to go about finding the correct <span>$\dot{m}$</span>.  The first is to guess.  We know that mass flow rate thru a pipe is equal to </p><p class="math-container">\[\dot{m} = \rho \bar{u} A\]</p><p>where <span>$\bar{u}$</span> is the average flow velocity thru cross section <span>$A$</span>.  We can assume that <span>$\bar{u} \approx \dot{x}$</span>.  Therefore we have</p><p class="math-container">\[\dot{m} = \rho \cdot \dot{x} \cdot A\]</p><p>The second way to find the correct <span>$\dot{m}$</span> is to solve for it directly.  We can do this by simply supplying the target <span>$x$</span> function as the input to the system.  In this example we will do both and compare the results.</p><p>To solve this in ModelingToolkit.jl, let&#39;s start by defining our parameters and <code>x</code> function</p><pre><code class="language-julia hljs">using ModelingToolkit
using DifferentialEquations
using Symbolics
using Plots

@parameters t
D = Differential(t)

# parameters -------
pars = @parameters begin
    r₀ = 876 #kg/s
    β = 1.2e9 #Pa
    A = 0.01 #m²
    x₀ = 1.0 #m
    M = 10_000 #kg
    g = 9.807 #m/s²
    amp = 5e-2 #m
    f = 15 #Hz
end

dt = 1e-4 #s
t_end = 0.2 #s
time = 0:dt:t_end

x_fun(t,amp,f) = amp*sin(2π*t*f) + x₀</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">x_fun (generic function with 1 method)</code></pre><p>Now, to supply <span>$\dot{m}$</span> we need an <span>$\dot{x}$</span> function.  This can be automatically generated for us with Symbolics.jl</p><pre><code class="language-julia hljs">ẋ_fun = build_function(expand_derivatives(D(x_fun(t,amp,f))), t, amp, f; expression=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RuntimeGeneratedFunction(#=in Symbolics=#, #=using Symbolics=#, :((t, amp, f)-&gt;begin
          #= /home/runner/.julia/packages/SymbolicUtils/r1pzW/src/code.jl:373 =#
          #= /home/runner/.julia/packages/SymbolicUtils/r1pzW/src/code.jl:374 =#
          #= /home/runner/.julia/packages/SymbolicUtils/r1pzW/src/code.jl:375 =#
          (*)((*)((*)(6.283185307179586, amp), f), (cos)((*)((*)(6.283185307179586, f), t)))
      end))</code></pre><p>As can be seen, we get a <code>cos</code> function as expected taking the derivative of <code>sin</code>.  Now let&#39;s build the variables and equations of our system.  The base equations are generated in a function so we can easily compare the correct derivation of mass balance (<code>density_type = r(t)</code>) with the standard practice (<code>density_type = r₀</code>).</p><pre><code class="language-julia hljs">vars = @variables begin
    x(t) = x₀
    ẋ(t)
    ẍ(t)
    p(t) = M*g/A #Pa
    ṁ(t)
    r(t)
    ṙ(t)
end

function get_base_equations(density_type)

    eqs = [
        D(x) ~ ẋ
        D(ẋ) ~ ẍ
        D(r) ~ ṙ

        r ~ r₀*(1 + p/β)

        ṁ ~ ṙ*x*A + (density_type)*ẋ*A
        M*ẍ ~ p*A - M*g
    ]

    return eqs
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">get_base_equations (generic function with 1 method)</code></pre><p>Note: we&#39;ve only specified the initial values for the known states of <code>x</code> and <code>p</code>.  We will find the additional unknown initial conditions before solving.  Now we have 7 variables defined and only 6 equations, missing the final driving input equation.  Let&#39;s build 3 different cases:</p><ul><li>case 1: mass flow guess using standard practice mass flow balance</li></ul><pre><code class="language-julia hljs">eqs_ṁ1 = [
    get_base_equations(r₀)...
    ṁ ~ ẋ_fun(t,amp,f)*A*r # (4) Input - mass flow guess
]</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d} x\left( t \right)}{\mathrm{d}t} =&amp; \textnormal{\.{x}}\left( t \right) \\
\frac{\mathrm{d} \textnormal{\.{x}}\left( t \right)}{\mathrm{d}t} =&amp; \textnormal{\&quot;{x}}\left( t \right) \\
\frac{\mathrm{d} r\left( t \right)}{\mathrm{d}t} =&amp; \textnormal{\.{r}}\left( t \right) \\
r\left( t \right) =&amp; r_0 \left( 1 + \frac{p\left( t \right)}{\beta} \right) \\
\textnormal{\.{m}}\left( t \right) =&amp; A r_0 \textnormal{\.{x}}\left( t \right) + A x\left( t \right) \textnormal{\.{r}}\left( t \right) \\
M \textnormal{\&quot;{x}}\left( t \right) =&amp; A p\left( t \right) - M g \\
\textnormal{\.{m}}\left( t \right) =&amp; 6.2832 A amp f r\left( t \right) \cos\left( 6.2832 f t \right)
\end{align}
 \]</p><ul><li>case 2: mass flow guess using correct compressibility equation</li></ul><pre><code class="language-julia hljs">eqs_ṁ2 = [
    get_base_equations(r)...
    ṁ ~ ẋ_fun(t,amp,f)*A*r # (4) Input - mass flow guess
]</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d} x\left( t \right)}{\mathrm{d}t} =&amp; \textnormal{\.{x}}\left( t \right) \\
\frac{\mathrm{d} \textnormal{\.{x}}\left( t \right)}{\mathrm{d}t} =&amp; \textnormal{\&quot;{x}}\left( t \right) \\
\frac{\mathrm{d} r\left( t \right)}{\mathrm{d}t} =&amp; \textnormal{\.{r}}\left( t \right) \\
r\left( t \right) =&amp; r_0 \left( 1 + \frac{p\left( t \right)}{\beta} \right) \\
\textnormal{\.{m}}\left( t \right) =&amp; A r\left( t \right) \textnormal{\.{x}}\left( t \right) + A x\left( t \right) \textnormal{\.{r}}\left( t \right) \\
M \textnormal{\&quot;{x}}\left( t \right) =&amp; A p\left( t \right) - M g \\
\textnormal{\.{m}}\left( t \right) =&amp; 6.2832 A amp f r\left( t \right) \cos\left( 6.2832 f t \right)
\end{align}
 \]</p><ul><li>case 3: solution</li></ul><pre><code class="language-julia hljs">eqs_x = [
    get_base_equations(r)...
    x ~ x_fun(t,amp,f) # (4) Input - target x
]</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d} x\left( t \right)}{\mathrm{d}t} =&amp; \textnormal{\.{x}}\left( t \right) \\
\frac{\mathrm{d} \textnormal{\.{x}}\left( t \right)}{\mathrm{d}t} =&amp; \textnormal{\&quot;{x}}\left( t \right) \\
\frac{\mathrm{d} r\left( t \right)}{\mathrm{d}t} =&amp; \textnormal{\.{r}}\left( t \right) \\
r\left( t \right) =&amp; r_0 \left( 1 + \frac{p\left( t \right)}{\beta} \right) \\
\textnormal{\.{m}}\left( t \right) =&amp; A r\left( t \right) \textnormal{\.{x}}\left( t \right) + A x\left( t \right) \textnormal{\.{r}}\left( t \right) \\
M \textnormal{\&quot;{x}}\left( t \right) =&amp; A p\left( t \right) - M g \\
x\left( t \right) =&amp; x_0 + amp \sin\left( 6.2832 f t \right)
\end{align}
 \]</p><p>Now we have 3 sets of equations, let&#39;s construct the systems and solve.  If we start with the 3rd system with the target <span>$x$</span> input, notice that the <code>structural_simplify</code> step outputs a system with 0 equations!</p><pre><code class="language-julia hljs">@named odesys_x = ODESystem(eqs_x, t, vars, pars)
sys_x = structural_simplify(odesys_x)</code></pre><p class="math-container">\[ \begin{align}
\end{align}
 \]</p><p>What this means is ModelingToolkit.jl has found that this model can be solved entirely analytically.  The full system of equations has been moved to what is called &quot;observables&quot;, which can be obtained using the <code>observed()</code> function</p><pre><code class="language-julia hljs">observed(sys_x)</code></pre><p class="math-container">\[ \begin{align}
xˍt\left( t \right) =&amp; 6.2832 amp f \cos\left( 6.2832 f t \right) \\
xˍtt\left( t \right) =&amp;  - 39.478 f^{2} amp \sin\left( 6.2832 f t \right) \\
xˍttt\left( t \right) =&amp;  - 248.05 f^{3} amp \cos\left( 6.2832 f t \right) \\
x\left( t \right) =&amp; x_0 + amp \sin\left( 6.2832 f t \right) \\
\textnormal{\.{x}}\left( t \right) =&amp; xˍt\left( t \right) \\
{\textnormal{\.{x}}}ˍt\left( t \right) =&amp; xˍtt\left( t \right) \\
{\textnormal{\.{x}}}ˍtt\left( t \right) =&amp; xˍttt\left( t \right) \\
\textnormal{\&quot;{x}}\left( t \right) =&amp; {\textnormal{\.{x}}}ˍt\left( t \right) \\
{\textnormal{\&quot;{x}}}ˍt\left( t \right) =&amp; {\textnormal{\.{x}}}ˍtt\left( t \right) \\
p\left( t \right) =&amp; \frac{ - M g - M \textnormal{\&quot;{x}}\left( t \right)}{ - A} \\
pˍt\left( t \right) =&amp; \frac{M {\textnormal{\&quot;{x}}}ˍt\left( t \right)}{A} \\
r\left( t \right) =&amp; r_0 \left( 1 + \frac{p\left( t \right)}{\beta} \right) \\
rˍt\left( t \right) =&amp; \frac{r_0 pˍt\left( t \right)}{\beta} \\
\textnormal{\.{r}}\left( t \right) =&amp; rˍt\left( t \right) \\
\textnormal{\.{m}}\left( t \right) =&amp; A r\left( t \right) \textnormal{\.{x}}\left( t \right) + A x\left( t \right) \textnormal{\.{r}}\left( t \right)
\end{align}
 \]</p><div class="admonition is-info"><header class="admonition-header">dummy derivatives</header><div class="admonition-body"><p>Some of the observables have a <code>ˍt</code> appended to the name.  These are called dummy derivatives, which are a consequence of the algorithm to reduce the system DAE index.  </p></div></div><p>This system can still be &quot;solved&quot; using the same steps to generate an <code>ODESolution</code> which allows us to easily obtain any calculated observed state.</p><pre><code class="language-julia hljs">prob_x = ODEProblem(sys_x, [], (0, t_end))
sol_x = solve(prob_x; saveat=time)
plot(sol_x; idxs=ṁ)</code></pre><img src="62fc0df3.svg" alt="Example block output"/><p>Now let&#39;s solve the other system and compare the results. </p><pre><code class="language-julia hljs">@named odesys_ṁ1 = ODESystem(eqs_ṁ1, t, vars, pars)
sys_ṁ1 = structural_simplify(odesys_ṁ1)</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d} x\left( t \right)}{\mathrm{d}t} =&amp; \textnormal{\.{x}}\left( t \right) \\
\frac{\mathrm{d} \textnormal{\.{x}}\left( t \right)}{\mathrm{d}t} =&amp; \textnormal{\&quot;{x}}\left( t \right) \\
\frac{\mathrm{d} r\left( t \right)}{\mathrm{d}t} =&amp; \textnormal{\.{r}}\left( t \right) \\
0 =&amp;  - \textnormal{\.{m}}\left( t \right) + A r_0 \textnormal{\.{x}}\left( t \right) + A x\left( t \right) \textnormal{\.{r}}\left( t \right)
\end{align}
 \]</p><p>Notice that now, with a simple change of the system input variable, <code>structural_simplify()</code> outputs a system with 4 states to be solved.  We can find the initial conditions needed for these states from <code>sol_x</code> and solve.</p><pre><code class="language-julia hljs">u0 = [sol_x[s][1] for s in states(sys_ṁ1)]
prob_ṁ1 = ODEProblem(sys_ṁ1, u0, (0, t_end))
sol_ṁ1 = solve(prob_ṁ1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: specialized 4rd order &quot;free&quot; stiffness-aware interpolation
t: 31-element Vector{Float64}:
 0.0
 1.0e-6
 1.1e-5
 0.00011099999999999999
 0.0004942017118269779
 0.0011835330472482494
 0.0020598647671780266
 0.0032218875341452416
 0.004861344890020217
 0.007005748974611168
 ⋮
 0.11273771024605896
 0.12233466014355993
 0.1334548991618538
 0.14457513818014767
 0.1561353788242516
 0.16564163543741278
 0.1761838860607496
 0.18672613668408644
 0.2
u: 31-element Vector{Vector{Float64}}:
 [1.0, 4.71238898038469, 883.1591099999999, 33.73651034300397]
 [1.0000047123889804, 4.7123889804077965, 883.1591437365049, 33.73649256933197]
 [1.0000518362787945, 4.712388983180629, 883.1594810934123, 33.73427215537168]
 [1.0005230751873497, 4.7123892647678876, 883.162846319372, 33.50860307074311]
 [1.002328871618151, 4.71239449810222, 883.1750390979231, 29.225006765604807]
 [1.0055772798802485, 4.712417214245918, 883.1888480213563, 7.942326308730165]
 [1.0097069357490036, 4.712449195563543, 883.1750664034553, -43.997115399660174]
 [1.0151828993463912, 4.712403383866454, 883.0641368220422, -154.7563834027399]
 [1.0229083011123798, 4.711775335054551, 882.6309306432345, -388.29744801181516]
 [1.0330094944904795, 4.708584827541247, 881.3615649402257, -817.3541412605887]
 ⋮
 [0.9291533601882774, -4.410107076100579, 903.9123406464753, 2498.919112228364]
 [0.8888390691480201, -3.8976262854655603, 946.7065968723274, 6396.99002002312]
 [0.8531465410747711, -2.301057617762443, 1032.4944229390367, 8065.17287767339]
 [0.8424788463123037, 0.5517581002449341, 1097.8168942291768, 2430.8374345667917]
 [0.8685014256760011, 3.8735995871668973, 1069.3066189990861, -7078.068611509789]
 [0.9152012015801158, 5.757789567802009, 980.9004131572324, -10538.424252225066]
 [0.9805659475503962, 6.391533210266907, 877.1921868776122, -8340.39743580704]
 [1.0455637265317124, 5.786000199079229, 813.536344388994, -3695.0742982598126]
 [1.1126605961299767, 4.266425852771705, 793.9295448928182, 3.5232800640996924]</code></pre><p>The resulting mass flow rate required to hit the target <span>$x$</span> position can be seen to be completely wrong.  This is the large impact that compressibility can have when high forces are involved.</p><pre><code class="language-julia hljs">plot(sol_ṁ1; idxs=ṁ, label=&quot;guess&quot;, ylabel=&quot;ṁ&quot;)
plot!(sol_x; idxs=ṁ, label=&quot;solution&quot;)</code></pre><img src="310f579c.svg" alt="Example block output"/><p>If we now solve for case 2, we can study the impact the compressibility derivation</p><pre><code class="language-julia hljs">@named odesys_ṁ2 = ODESystem(eqs_ṁ2, t, vars, pars)
sys_ṁ2 = structural_simplify(odesys_ṁ2)
prob_ṁ2 = ODEProblem(sys_ṁ2, u0, (0, t_end))
sol_ṁ2 = solve(prob_ṁ2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: specialized 4rd order &quot;free&quot; stiffness-aware interpolation
t: 36-element Vector{Float64}:
 0.0
 1.0e-6
 1.1e-5
 4.9198699973759645e-5
 0.00014835295692478884
 0.00035332690939544615
 0.0007131952509047657
 0.0012748590025987517
 0.0020804382530610907
 0.003218462506949036
 ⋮
 0.12784453221960848
 0.13781206179899286
 0.14777959137837723
 0.15564593895469458
 0.16473461915773263
 0.17382329936077068
 0.18333795843461984
 0.19637168112612655
 0.2
u: 36-element Vector{Vector{Float64}}:
 [1.0, 4.71238898038469, 883.1591099999999, -4.155396027272218e-9]
 [1.0000047123889804, 4.71238898038469, 883.1591099999939, -1.8483757752063162e-5]
 [1.0000518362787842, 4.712388980384658, 883.1591099917997, -0.002236429221099799]
 [1.0002318434116055, 4.712388980372329, 883.1591092664058, -0.0447299113227813]
 [1.0006990968393896, 4.712388979363068, 883.1590898939277, -0.4065118423603375]
 [1.001665013831987, 4.712388947534045, 883.1588385862359, -2.303443375854742]
 [1.0033608533635006, 4.712388435665157, 883.1568810962762, -9.36623879812736]
 [1.0060076300991176, 4.7123834298362715, 883.1464116672927, -29.82054896567352]
 [1.0098038179485016, 4.712349740931142, 883.1041565943988, -78.93277058759153]
 [1.0151665029801127, 4.712165410354035, 882.9570910173196, -186.92548881266453]
 ⋮
 [0.8722967471393573, -3.4301188608415214, 989.0889549821868, 8533.500617832746]
 [0.847285722156934, -1.393740380833991, 1073.3841339572573, 7211.494805164612]
 [0.8476107140315731, 1.5430763549160131, 1109.6915632937425, -738.3875059299742]
 [0.869059080703531, 3.847296765734049, 1075.0467073379748, -7716.717876012542]
 [0.9133322335871806, 5.705840432778143, 984.6326281817819, -11147.620738052989]
 [0.9690484916447569, 6.355440637384056, 889.0704122230483, -9207.516124266647]
 [1.0282803879389866, 5.94954735278846, 822.1079242474973, -4754.9913904974255]
 [1.0970485109110262, 4.5232322399883715, 794.7677234572918, -60.632577495780346]
 [1.112664281574073, 4.0851882327603555, 795.5938248707337, 448.4705291590855]</code></pre><p>As can be seen, a significant error forms between the 2 cases. </p><pre><code class="language-julia hljs">plot(sol_x; idxs=x, label=&quot;solution&quot;, ylabel=&quot;x&quot;)
plot!(sol_ṁ1; idxs=x, label=&quot;case 1: r₀&quot;)
plot!(sol_ṁ2; idxs=x, label=&quot;case 2: r&quot;)</code></pre><img src="4f319bc4.svg" alt="Example block output"/><pre><code class="language-julia hljs">plot(time, (sol_ṁ1(time)[x] .- sol_ṁ2(time)[x])/1e-3, label=&quot;x&quot;, ylabel=&quot;error (case 1 - case 2) [mm]&quot;, xlabel=&quot;t [s]&quot;)</code></pre><img src="a5e3ec92.svg" alt="Example block output"/><h3 id="Practice-Problem"><a class="docs-heading-anchor" href="#Practice-Problem">Practice Problem</a><a id="Practice-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Practice-Problem" title="Permalink"></a></h3><p>Now let&#39;s re-create this example using components from the ModelingToolkitStandardLibrary.jl.  It can be shown that by connecting <code>Mass</code> and <code>Volume</code> components that the same exact result is achieved.  The important thing is to pay very close attention to the initial conditions.  </p><pre><code class="language-julia hljs">import ModelingToolkitStandardLibrary.Mechanical.Translational as T
import ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible as IC
import ModelingToolkitStandardLibrary.Blocks as B

using DataInterpolations
mass_flow_fun = LinearInterpolation(sol_x[ṁ], sol_x.t)

include(&quot;volume.jl&quot;) # &lt;-- missing Volume component from MTKSL (will be released in new version)

function MassVolume(; name, dx, drho, dm)

    pars = @parameters begin
        A = 0.01 #m²
        x₀ = 1.0 #m
        M = 10_000 #kg
        g = 9.807 #m/s²
        amp = 5e-2 #m
        f = 15 #Hz
        p_int=M*g/A
        dx=dx
        drho=drho
        dm=dm
    end
    vars = []
    systems = @named begin
        fluid = IC.HydraulicFluid(; density = 876, bulk_modulus = 1.2e9)
        mass = T.Mass(;v=dx,m=M,g=-g)
        vol = Volume(;area=A, x=x₀, p=p_int, dx, drho, dm) # &lt;-- missing Volume component from MTKSL (will be released in new version)
        mass_flow = IC.MassFlow(;p_int)
        mass_flow_input = B.TimeVaryingFunction(;f = mass_flow_fun)
    end

    eqs = [
        connect(mass.flange, vol.flange)
        connect(vol.port, mass_flow.port)
        connect(mass_flow.dm, mass_flow_input.output)
        connect(mass_flow.port, fluid)
    ]

    return ODESystem(eqs, t, vars, pars; systems, name)
end

dx = sol_x[ẋ][1]
drho = sol_x[ṙ][1]
dm = sol_x[ṁ][1]

@named odesys = MassVolume(; dx, drho, dm)

sys = structural_simplify(odesys)

prob = ODEProblem(sys, [], (0, t_end))
sol=solve(prob)

plot(sol; idxs=sys.vol.x, linewidth=2)
plot!(sol_x; idxs=x)</code></pre><img src="dde1c55b.svg" alt="Example block output"/><h2 id="Momentum-Balance"><a class="docs-heading-anchor" href="#Momentum-Balance">Momentum Balance</a><a id="Momentum-Balance-1"></a><a class="docs-heading-anchor-permalink" href="#Momentum-Balance" title="Permalink"></a></h2><p>The next challenging aspect of hydraulic modeling is modeling flow through a pipe, which for compressible flow requires resolving the momentum balance equation. To derive the momentum balance we can draw a control volume (cv) in a pipe with area <span>$A$</span>, as shown in the figure below, and apply Newton&#39;s second law.  Across this control volume from <span>$x_1$</span> to <span>$x_2$</span> the pressure will change from <span>$p_1$</span> to <span>$p_2$</span>.  Assuming this is written for an acausal component we put nodes at <span>$p_1$</span> to <span>$p_2$</span> which will have equal mass flow <span>$\dot{m}$</span> entering and exiting the cv<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>.</p><p>Now taking the sum of forces acting on the cv we have the pressure forces at each end as well as the viscous drag force from the pipe wall and the body force from gravity.  The sum of forces is equal to the product of mass (<span>$\rho V$</span>) and flow acceleration (<span>$\dot{u}$</span>).   </p><p class="math-container">\[    \rho V \dot{u} = p_1 A_1 - p_2 A_2 - F_{viscous} + \rho V g\]</p><div class="admonition is-info"><header class="admonition-header">Project Idea</header><div class="admonition-body"><p>the current implementation of this component in the ModelingToolkitStandardLibrary.jl does not include gravity force for this makes initialization challenging and will take some work to implement.</p></div></div><p>The density <span>$\rho$</span> is an average of <span>$\rho_1$</span> and <span>$\rho_2$</span>.  The velocity is also taken as an average of <span>$u_1$</span> and <span>$u_2$</span></p><p class="math-container">\[u_1 = \frac{\dot{m}}{\rho_1 A}\]</p><p class="math-container">\[u_2 = \frac{\dot{m}}{\rho_2 A}\]</p><p><img src="../../img/momentum_balance.svg" alt="momentum balance"/></p><div class="admonition is-info"><header class="admonition-header">Conservation of Momentum</header><div class="admonition-body"></div></div><p>the term <code>\rho V \dot{u}</code> introduces what is referd to as fluid inertia.  This is what resolves the pressure wave propagation through a pipe.  A classic wave propagation example in pipes is the &quot;water hammer&quot; effect.  The full derivation for the flow velocity derivative is when deriving in 2 dimensions is </p><p class="math-container">\[   \frac{D \text{V}}{Dt} = \frac{\partial \text{V}}{\partial t} + \frac{\partial \text{V}}{\partial x} u + \frac{\partial \text{V}}{\partial z} w
   ```
   where $\text{v}$ is the velocity vector, $u$ and $w$ are the flow components in $x$ and $y$ directions.  In the ModelingToolkitStandardLibrary.jl this assumption is taken
   ```math
   \rho V \frac{D \text{V}}{Dt} \approx \frac{\partial \dot{m}}{\partial t}
   ```  
   

!!! note &quot;Project Idea&quot;
    Implement a more detailed Conservation of Momentum using the standard derivation.  One idea is to implement the MethodOfLines.jl to provide the derivative in $x$.
    

### Pipe Component
To model a pipe for compressible flow, we can combine the mass balance and momentum balance components to give both mass storage and flow resistance.  Furthermore, to provide a more accurate model that allows for wave propagation we can discretize the volume connected by node of equal pressure and mass flow.  The diagram below shows an example of discretizing with 3 mass balance volumes and 2 momentum balance resistive elements.  Note: the Modelica Standard Library does this in a different way, by combining the mass and momentum balance in a single base class.  

![pipe](../img/pipe.svg)


### Dynamic Volume Component
Both Modelica and SimScape model the actuator component with simply a uniform pressure volume component.  The Modelica library defines the base fluids class around the assumption of constant length (see: [Object-Oriented Modeling of Thermo-Fluid Systems](https://elib.dlr.de/11988/1/otter2003-modelica-fluid.pdf)) and therefore adapting to a component that changes length is not possible.  But in cases with long actuators with high dynamics the pressure is not at all uniform, therefore this detail cannot be ignored.  Therefore, adding in the momentum balance to provide flow resistance and fluid inertia are necessary.  The diagram below shows the design of a `DynamicVolume` component which includes both mass and momentum balance in addition to discretization by volume.  The discretization is similar to the pipe, except the scheme becomes a bit more complicated with the moving wall ($x$).  As the volume shrinks, the control volumes will also shrink, however not in unison, but one at a time.  In this way, as the moving wall closes, the flow will come from the first volume $cv1$ and travel thru the full size remaining elements ($cv2$, $cv3$, etc.).  After the first component length drops to zero, the next element will then start to shrink.  

![volume](../img/volume.svg)

This design has a flaw unfortunately, expanding the system for N=3 gives 

![eqs1](../img/volume_eq1.png)

What happens when transitioning from one cv to the next, if the moving wall velocity is significant, then an abrupt change occurs due to the $\rho_i \dot{x}$ term.  This creates an unstable condition for the solver and results in poor quality/accuracy.  To resolve this problem, the mass balance equation is split into 2 parts: mass balance 1 \&amp; 2 
\]</p><p>math \text{mass balance 1: } \dot{m}/A = \dot{\rho} x</p><pre><code class="nohighlight hljs"></code></pre><p>math \text{mass balance 2: } \dot{m}/A = \rho \dot{x} ```</p><p>The below diagram explains how this component is constructed</p><p><img src="../../img/dynamic_volume.svg" alt="dynamic volume"/></p><p>Now the flows are simplified and are more numerically stable.  The acausal connections then handle the proper summing of flows.</p><p><img src="../../img/volume_eq2.png" alt="eqs2"/></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>See <a href="https://www.mathworks.com/help/simscape/ref/variablehydraulicchamber.html">simscape hydraulic chamber</a>.  Note the deprecation warning moving to isothermal liquid library which uses the correct derivation.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>The Modelica Standard Library combines the mass and momentum balance to the same base class, therefore, mass flow in and out of the cv is not equal, which introduces an additional term to the lhs of the momentum balance:  $ \frac{\partial \left( \rho u^2 A \right) }{\partial x}  $  </li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lecture1/">« Lecture 1: Introduction to acausal modeling for physical systems with ModelingToolkit.jl</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 9 January 2024 18:11">Tuesday 9 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
